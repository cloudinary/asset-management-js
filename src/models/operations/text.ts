/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type TextGlobals = {
  /**
   * The cloud name of your product environment.
   */
  cloudName?: string | undefined;
};

/**
 * The type of resource to create. Must be "image" for text generation.
 */
export const TextResourceType = {
  Image: "image",
} as const;
/**
 * The type of resource to create. Must be "image" for text generation.
 */
export type TextResourceType = ClosedEnum<typeof TextResourceType>;

/**
 * Text alignment (left, center, right, justify).
 */
export const TextAlign = {
  Left: "left",
  Center: "center",
  Right: "right",
  Justify: "justify",
} as const;
/**
 * Text alignment (left, center, right, justify).
 */
export type TextAlign = ClosedEnum<typeof TextAlign>;

/**
 * Whether to use a normal or bold font.
 */
export const FontWeight = {
  Normal: "normal",
  Bold: "bold",
} as const;
/**
 * Whether to use a normal or bold font.
 */
export type FontWeight = ClosedEnum<typeof FontWeight>;

/**
 * Whether to use a normal or italic font.
 */
export const FontStyle = {
  Normal: "normal",
  Italic: "italic",
} as const;
/**
 * Whether to use a normal or italic font.
 */
export type FontStyle = ClosedEnum<typeof FontStyle>;

/**
 * Text decoration style.
 */
export const TextDecoration = {
  None: "none",
  Underline: "underline",
} as const;
/**
 * Text decoration style.
 */
export type TextDecoration = ClosedEnum<typeof TextDecoration>;

export type TextRequestBody = {
  /**
   * The text string to generate an image for.
   */
  text: string;
  /**
   * The identifier that is used for accessing the generated image. If not specified, a unique identifier is generated.
   */
  publicId?: string | undefined;
  /**
   * The name of the font family.
   */
  fontFamily?: string | undefined;
  /**
   * Font size in points.
   */
  fontSize?: number | undefined;
  /**
   * Name or RGB representation of the font's color (e.g., red or
   */
  fontColor?: string | undefined;
  /**
   * Text alignment (left, center, right, justify).
   */
  textAlign?: TextAlign | undefined;
  /**
   * Whether to use a normal or bold font.
   */
  fontWeight?: FontWeight | undefined;
  /**
   * Whether to use a normal or italic font.
   */
  fontStyle?: FontStyle | undefined;
  /**
   * Name or RGB representation of the background color (e.g., red or
   */
  background?: string | undefined;
  /**
   * Text opacity value between 0 (invisible) and 100.
   */
  opacity?: number | undefined;
  /**
   * Text decoration style.
   */
  textDecoration?: TextDecoration | undefined;
  /**
   * The spacing between lines of text in pixels.
   */
  lineSpacing?: number | undefined;
};

export type TextRequest = {
  /**
   * The type of resource to create. Must be "image" for text generation.
   */
  resourceType: TextResourceType;
  requestBody: TextRequestBody;
};

export type AccessControl = {};

export type Region = {};

/**
 * Moderation information for the asset.
 */
export type TextModeration = {};

/**
 * Additional information about the asset.
 */
export type Info = {};

/**
 * Text image created successfully
 */
export type TextResponse = {
  /**
   * The unique identifier of the asset.
   */
  assetId: string;
  /**
   * The public identifier of the asset.
   */
  publicId: string;
  /**
   * The version number of the asset.
   */
  version: number;
  /**
   * The version identifier of the asset.
   */
  versionId: string;
  /**
   * The signature for the asset.
   */
  signature: string;
  /**
   * The width of the generated image in pixels.
   */
  width: number;
  /**
   * The height of the generated image in pixels.
   */
  height: number;
  /**
   * The format of the generated image.
   */
  format: string;
  /**
   * The type of resource (image).
   */
  resourceType: string;
  /**
   * The creation timestamp.
   */
  createdAt: Date;
  /**
   * Array of tags assigned to the asset.
   */
  tags?: Array<string> | undefined;
  /**
   * Number of pages in the asset.
   */
  pages?: number | undefined;
  /**
   * Size of the asset in bytes.
   */
  bytes: number;
  /**
   * The storage type of the asset.
   */
  type: string;
  /**
   * The ETag of the asset.
   */
  etag?: string | undefined;
  /**
   * Whether the asset is a placeholder.
   */
  placeholder?: boolean | undefined;
  /**
   * The HTTP URL for accessing the asset.
   */
  url: string;
  /**
   * The HTTPS URL for accessing the asset.
   */
  secureUrl: string;
  /**
   * The display name of the asset.
   */
  displayName?: string | undefined;
  /**
   * The access mode of the asset.
   */
  accessMode?: string | undefined;
  /**
   * Access control settings for the asset.
   */
  accessControl?: Array<AccessControl> | undefined;
  /**
   * Region information for the asset.
   */
  regions?: Array<Region> | undefined;
  /**
   * Moderation information for the asset.
   */
  moderation?: TextModeration | undefined;
  /**
   * Additional information about the asset.
   */
  info?: Info | undefined;
};

/** @internal */
export const TextGlobals$inboundSchema: z.ZodType<
  TextGlobals,
  z.ZodTypeDef,
  unknown
> = z.object({
  cloud_name: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "cloud_name": "cloudName",
  });
});

/** @internal */
export type TextGlobals$Outbound = {
  cloud_name?: string | undefined;
};

/** @internal */
export const TextGlobals$outboundSchema: z.ZodType<
  TextGlobals$Outbound,
  z.ZodTypeDef,
  TextGlobals
> = z.object({
  cloudName: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    cloudName: "cloud_name",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TextGlobals$ {
  /** @deprecated use `TextGlobals$inboundSchema` instead. */
  export const inboundSchema = TextGlobals$inboundSchema;
  /** @deprecated use `TextGlobals$outboundSchema` instead. */
  export const outboundSchema = TextGlobals$outboundSchema;
  /** @deprecated use `TextGlobals$Outbound` instead. */
  export type Outbound = TextGlobals$Outbound;
}

export function textGlobalsToJSON(textGlobals: TextGlobals): string {
  return JSON.stringify(TextGlobals$outboundSchema.parse(textGlobals));
}

export function textGlobalsFromJSON(
  jsonString: string,
): SafeParseResult<TextGlobals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TextGlobals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TextGlobals' from JSON`,
  );
}

/** @internal */
export const TextResourceType$inboundSchema: z.ZodNativeEnum<
  typeof TextResourceType
> = z.nativeEnum(TextResourceType);

/** @internal */
export const TextResourceType$outboundSchema: z.ZodNativeEnum<
  typeof TextResourceType
> = TextResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TextResourceType$ {
  /** @deprecated use `TextResourceType$inboundSchema` instead. */
  export const inboundSchema = TextResourceType$inboundSchema;
  /** @deprecated use `TextResourceType$outboundSchema` instead. */
  export const outboundSchema = TextResourceType$outboundSchema;
}

/** @internal */
export const TextAlign$inboundSchema: z.ZodNativeEnum<typeof TextAlign> = z
  .nativeEnum(TextAlign);

/** @internal */
export const TextAlign$outboundSchema: z.ZodNativeEnum<typeof TextAlign> =
  TextAlign$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TextAlign$ {
  /** @deprecated use `TextAlign$inboundSchema` instead. */
  export const inboundSchema = TextAlign$inboundSchema;
  /** @deprecated use `TextAlign$outboundSchema` instead. */
  export const outboundSchema = TextAlign$outboundSchema;
}

/** @internal */
export const FontWeight$inboundSchema: z.ZodNativeEnum<typeof FontWeight> = z
  .nativeEnum(FontWeight);

/** @internal */
export const FontWeight$outboundSchema: z.ZodNativeEnum<typeof FontWeight> =
  FontWeight$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FontWeight$ {
  /** @deprecated use `FontWeight$inboundSchema` instead. */
  export const inboundSchema = FontWeight$inboundSchema;
  /** @deprecated use `FontWeight$outboundSchema` instead. */
  export const outboundSchema = FontWeight$outboundSchema;
}

/** @internal */
export const FontStyle$inboundSchema: z.ZodNativeEnum<typeof FontStyle> = z
  .nativeEnum(FontStyle);

/** @internal */
export const FontStyle$outboundSchema: z.ZodNativeEnum<typeof FontStyle> =
  FontStyle$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FontStyle$ {
  /** @deprecated use `FontStyle$inboundSchema` instead. */
  export const inboundSchema = FontStyle$inboundSchema;
  /** @deprecated use `FontStyle$outboundSchema` instead. */
  export const outboundSchema = FontStyle$outboundSchema;
}

/** @internal */
export const TextDecoration$inboundSchema: z.ZodNativeEnum<
  typeof TextDecoration
> = z.nativeEnum(TextDecoration);

/** @internal */
export const TextDecoration$outboundSchema: z.ZodNativeEnum<
  typeof TextDecoration
> = TextDecoration$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TextDecoration$ {
  /** @deprecated use `TextDecoration$inboundSchema` instead. */
  export const inboundSchema = TextDecoration$inboundSchema;
  /** @deprecated use `TextDecoration$outboundSchema` instead. */
  export const outboundSchema = TextDecoration$outboundSchema;
}

/** @internal */
export const TextRequestBody$inboundSchema: z.ZodType<
  TextRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  public_id: z.string().optional(),
  font_family: z.string().optional(),
  font_size: z.number().int().default(12),
  font_color: z.string().default("black"),
  text_align: TextAlign$inboundSchema.optional(),
  font_weight: FontWeight$inboundSchema.default("normal"),
  font_style: FontStyle$inboundSchema.default("normal"),
  background: z.string().default("transparent"),
  opacity: z.number().int().default(100),
  text_decoration: TextDecoration$inboundSchema.default("none"),
  line_spacing: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    "public_id": "publicId",
    "font_family": "fontFamily",
    "font_size": "fontSize",
    "font_color": "fontColor",
    "text_align": "textAlign",
    "font_weight": "fontWeight",
    "font_style": "fontStyle",
    "text_decoration": "textDecoration",
    "line_spacing": "lineSpacing",
  });
});

/** @internal */
export type TextRequestBody$Outbound = {
  text: string;
  public_id?: string | undefined;
  font_family?: string | undefined;
  font_size: number;
  font_color: string;
  text_align?: string | undefined;
  font_weight: string;
  font_style: string;
  background: string;
  opacity: number;
  text_decoration: string;
  line_spacing?: number | undefined;
};

/** @internal */
export const TextRequestBody$outboundSchema: z.ZodType<
  TextRequestBody$Outbound,
  z.ZodTypeDef,
  TextRequestBody
> = z.object({
  text: z.string(),
  publicId: z.string().optional(),
  fontFamily: z.string().optional(),
  fontSize: z.number().int().default(12),
  fontColor: z.string().default("black"),
  textAlign: TextAlign$outboundSchema.optional(),
  fontWeight: FontWeight$outboundSchema.default("normal"),
  fontStyle: FontStyle$outboundSchema.default("normal"),
  background: z.string().default("transparent"),
  opacity: z.number().int().default(100),
  textDecoration: TextDecoration$outboundSchema.default("none"),
  lineSpacing: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    publicId: "public_id",
    fontFamily: "font_family",
    fontSize: "font_size",
    fontColor: "font_color",
    textAlign: "text_align",
    fontWeight: "font_weight",
    fontStyle: "font_style",
    textDecoration: "text_decoration",
    lineSpacing: "line_spacing",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TextRequestBody$ {
  /** @deprecated use `TextRequestBody$inboundSchema` instead. */
  export const inboundSchema = TextRequestBody$inboundSchema;
  /** @deprecated use `TextRequestBody$outboundSchema` instead. */
  export const outboundSchema = TextRequestBody$outboundSchema;
  /** @deprecated use `TextRequestBody$Outbound` instead. */
  export type Outbound = TextRequestBody$Outbound;
}

export function textRequestBodyToJSON(
  textRequestBody: TextRequestBody,
): string {
  return JSON.stringify(TextRequestBody$outboundSchema.parse(textRequestBody));
}

export function textRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<TextRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TextRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TextRequestBody' from JSON`,
  );
}

/** @internal */
export const TextRequest$inboundSchema: z.ZodType<
  TextRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource_type: TextResourceType$inboundSchema,
  RequestBody: z.lazy(() => TextRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "resource_type": "resourceType",
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type TextRequest$Outbound = {
  resource_type: string;
  RequestBody: TextRequestBody$Outbound;
};

/** @internal */
export const TextRequest$outboundSchema: z.ZodType<
  TextRequest$Outbound,
  z.ZodTypeDef,
  TextRequest
> = z.object({
  resourceType: TextResourceType$outboundSchema,
  requestBody: z.lazy(() => TextRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    resourceType: "resource_type",
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TextRequest$ {
  /** @deprecated use `TextRequest$inboundSchema` instead. */
  export const inboundSchema = TextRequest$inboundSchema;
  /** @deprecated use `TextRequest$outboundSchema` instead. */
  export const outboundSchema = TextRequest$outboundSchema;
  /** @deprecated use `TextRequest$Outbound` instead. */
  export type Outbound = TextRequest$Outbound;
}

export function textRequestToJSON(textRequest: TextRequest): string {
  return JSON.stringify(TextRequest$outboundSchema.parse(textRequest));
}

export function textRequestFromJSON(
  jsonString: string,
): SafeParseResult<TextRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TextRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TextRequest' from JSON`,
  );
}

/** @internal */
export const AccessControl$inboundSchema: z.ZodType<
  AccessControl,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type AccessControl$Outbound = {};

/** @internal */
export const AccessControl$outboundSchema: z.ZodType<
  AccessControl$Outbound,
  z.ZodTypeDef,
  AccessControl
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AccessControl$ {
  /** @deprecated use `AccessControl$inboundSchema` instead. */
  export const inboundSchema = AccessControl$inboundSchema;
  /** @deprecated use `AccessControl$outboundSchema` instead. */
  export const outboundSchema = AccessControl$outboundSchema;
  /** @deprecated use `AccessControl$Outbound` instead. */
  export type Outbound = AccessControl$Outbound;
}

export function accessControlToJSON(accessControl: AccessControl): string {
  return JSON.stringify(AccessControl$outboundSchema.parse(accessControl));
}

export function accessControlFromJSON(
  jsonString: string,
): SafeParseResult<AccessControl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AccessControl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AccessControl' from JSON`,
  );
}

/** @internal */
export const Region$inboundSchema: z.ZodType<Region, z.ZodTypeDef, unknown> = z
  .object({});

/** @internal */
export type Region$Outbound = {};

/** @internal */
export const Region$outboundSchema: z.ZodType<
  Region$Outbound,
  z.ZodTypeDef,
  Region
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Region$ {
  /** @deprecated use `Region$inboundSchema` instead. */
  export const inboundSchema = Region$inboundSchema;
  /** @deprecated use `Region$outboundSchema` instead. */
  export const outboundSchema = Region$outboundSchema;
  /** @deprecated use `Region$Outbound` instead. */
  export type Outbound = Region$Outbound;
}

export function regionToJSON(region: Region): string {
  return JSON.stringify(Region$outboundSchema.parse(region));
}

export function regionFromJSON(
  jsonString: string,
): SafeParseResult<Region, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Region$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Region' from JSON`,
  );
}

/** @internal */
export const TextModeration$inboundSchema: z.ZodType<
  TextModeration,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type TextModeration$Outbound = {};

/** @internal */
export const TextModeration$outboundSchema: z.ZodType<
  TextModeration$Outbound,
  z.ZodTypeDef,
  TextModeration
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TextModeration$ {
  /** @deprecated use `TextModeration$inboundSchema` instead. */
  export const inboundSchema = TextModeration$inboundSchema;
  /** @deprecated use `TextModeration$outboundSchema` instead. */
  export const outboundSchema = TextModeration$outboundSchema;
  /** @deprecated use `TextModeration$Outbound` instead. */
  export type Outbound = TextModeration$Outbound;
}

export function textModerationToJSON(textModeration: TextModeration): string {
  return JSON.stringify(TextModeration$outboundSchema.parse(textModeration));
}

export function textModerationFromJSON(
  jsonString: string,
): SafeParseResult<TextModeration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TextModeration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TextModeration' from JSON`,
  );
}

/** @internal */
export const Info$inboundSchema: z.ZodType<Info, z.ZodTypeDef, unknown> = z
  .object({});

/** @internal */
export type Info$Outbound = {};

/** @internal */
export const Info$outboundSchema: z.ZodType<Info$Outbound, z.ZodTypeDef, Info> =
  z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Info$ {
  /** @deprecated use `Info$inboundSchema` instead. */
  export const inboundSchema = Info$inboundSchema;
  /** @deprecated use `Info$outboundSchema` instead. */
  export const outboundSchema = Info$outboundSchema;
  /** @deprecated use `Info$Outbound` instead. */
  export type Outbound = Info$Outbound;
}

export function infoToJSON(info: Info): string {
  return JSON.stringify(Info$outboundSchema.parse(info));
}

export function infoFromJSON(
  jsonString: string,
): SafeParseResult<Info, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Info$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Info' from JSON`,
  );
}

/** @internal */
export const TextResponse$inboundSchema: z.ZodType<
  TextResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  asset_id: z.string(),
  public_id: z.string(),
  version: z.number().int(),
  version_id: z.string(),
  signature: z.string(),
  width: z.number().int(),
  height: z.number().int(),
  format: z.string(),
  resource_type: z.string(),
  created_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  tags: z.array(z.string()).optional(),
  pages: z.number().int().optional(),
  bytes: z.number().int(),
  type: z.string(),
  etag: z.string().optional(),
  placeholder: z.boolean().optional(),
  url: z.string(),
  secure_url: z.string(),
  display_name: z.string().optional(),
  access_mode: z.string().optional(),
  access_control: z.array(z.lazy(() => AccessControl$inboundSchema)).optional(),
  regions: z.array(z.lazy(() => Region$inboundSchema)).optional(),
  moderation: z.lazy(() => TextModeration$inboundSchema).optional(),
  info: z.lazy(() => Info$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "asset_id": "assetId",
    "public_id": "publicId",
    "version_id": "versionId",
    "resource_type": "resourceType",
    "created_at": "createdAt",
    "secure_url": "secureUrl",
    "display_name": "displayName",
    "access_mode": "accessMode",
    "access_control": "accessControl",
  });
});

/** @internal */
export type TextResponse$Outbound = {
  asset_id: string;
  public_id: string;
  version: number;
  version_id: string;
  signature: string;
  width: number;
  height: number;
  format: string;
  resource_type: string;
  created_at: string;
  tags?: Array<string> | undefined;
  pages?: number | undefined;
  bytes: number;
  type: string;
  etag?: string | undefined;
  placeholder?: boolean | undefined;
  url: string;
  secure_url: string;
  display_name?: string | undefined;
  access_mode?: string | undefined;
  access_control?: Array<AccessControl$Outbound> | undefined;
  regions?: Array<Region$Outbound> | undefined;
  moderation?: TextModeration$Outbound | undefined;
  info?: Info$Outbound | undefined;
};

/** @internal */
export const TextResponse$outboundSchema: z.ZodType<
  TextResponse$Outbound,
  z.ZodTypeDef,
  TextResponse
> = z.object({
  assetId: z.string(),
  publicId: z.string(),
  version: z.number().int(),
  versionId: z.string(),
  signature: z.string(),
  width: z.number().int(),
  height: z.number().int(),
  format: z.string(),
  resourceType: z.string(),
  createdAt: z.date().transform(v => v.toISOString()),
  tags: z.array(z.string()).optional(),
  pages: z.number().int().optional(),
  bytes: z.number().int(),
  type: z.string(),
  etag: z.string().optional(),
  placeholder: z.boolean().optional(),
  url: z.string(),
  secureUrl: z.string(),
  displayName: z.string().optional(),
  accessMode: z.string().optional(),
  accessControl: z.array(z.lazy(() => AccessControl$outboundSchema)).optional(),
  regions: z.array(z.lazy(() => Region$outboundSchema)).optional(),
  moderation: z.lazy(() => TextModeration$outboundSchema).optional(),
  info: z.lazy(() => Info$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    assetId: "asset_id",
    publicId: "public_id",
    versionId: "version_id",
    resourceType: "resource_type",
    createdAt: "created_at",
    secureUrl: "secure_url",
    displayName: "display_name",
    accessMode: "access_mode",
    accessControl: "access_control",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TextResponse$ {
  /** @deprecated use `TextResponse$inboundSchema` instead. */
  export const inboundSchema = TextResponse$inboundSchema;
  /** @deprecated use `TextResponse$outboundSchema` instead. */
  export const outboundSchema = TextResponse$outboundSchema;
  /** @deprecated use `TextResponse$Outbound` instead. */
  export type Outbound = TextResponse$Outbound;
}

export function textResponseToJSON(textResponse: TextResponse): string {
  return JSON.stringify(TextResponse$outboundSchema.parse(textResponse));
}

export function textResponseFromJSON(
  jsonString: string,
): SafeParseResult<TextResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TextResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TextResponse' from JSON`,
  );
}
