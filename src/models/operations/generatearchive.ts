/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type GenerateArchiveGlobals = {
  /**
   * The cloud name of your product environment.
   */
  cloudName?: string | undefined;
};

/**
 * The type of resources to include in the archive. "image" for images, "video" for videos, "raw" for non-media files, or "all" for mixed types.
 */
export const GenerateArchiveResourceType = {
  Image: "image",
  Video: "video",
  Raw: "raw",
  All: "all",
} as const;
/**
 * The type of resources to include in the archive. "image" for images, "video" for videos, "raw" for non-media files, or "all" for mixed types.
 */
export type GenerateArchiveResourceType = ClosedEnum<
  typeof GenerateArchiveResourceType
>;

/**
 * The specific file type of assets to include in the archive. Not applicable when "resource_type" is "all".
 */
export const GenerateArchiveType = {
  Upload: "upload",
  Private: "private",
  Authenticated: "authenticated",
  Fetch: "fetch",
} as const;
/**
 * The specific file type of assets to include in the archive. Not applicable when "resource_type" is "all".
 */
export type GenerateArchiveType = ClosedEnum<typeof GenerateArchiveType>;

/**
 * The method for generating and delivering the archive. Options:
 *
 * @remarks
 * download - Generates and delivers the archive file without storing it
 * create - Creates and stores the archive as a raw asset, returning URLs in the response
 * create_and_download - Creates, stores, and delivers the archive file
 */
export const Mode = {
  Download: "download",
  Create: "create",
  CreateAndDownload: "create_and_download",
} as const;
/**
 * The method for generating and delivering the archive. Options:
 *
 * @remarks
 * download - Generates and delivers the archive file without storing it
 * create - Creates and stores the archive as a raw asset, returning URLs in the response
 * create_and_download - Creates, stores, and delivers the archive file
 */
export type Mode = ClosedEnum<typeof Mode>;

/**
 * The format of the generated archive.
 */
export const TargetFormat = {
  Zip: "zip",
  Tgz: "tgz",
} as const;
/**
 * The format of the generated archive.
 */
export type TargetFormat = ClosedEnum<typeof TargetFormat>;

export type GenerateArchiveRequestBody = {
  /**
   * (Required for signed REST API calls) Used to authenticate the request and based on the parameters you use in the request. When using the Cloudinary SDKs for signed requests, the signature is automatically generated and added to the request. If you manually generate your own signed POST request, you need to manually generate the signature parameter and add it to the request together with the api_key and timestamp parameters.
   *
   * @remarks
   */
  signature?: string | undefined;
  /**
   * The timestamp to use for the request in unix time. This is automatically computed by the Cloudinary's SDKs.
   */
  timestamp?: number | undefined;
  /**
   * The API key to use for the request. This is automatically computed by the Cloudinary's SDKs.
   */
  apiKey?: string | undefined;
  /**
   * The list of public IDs to include in the archive. Up to 1000 public IDs are supported.
   */
  publicIds?: Array<string> | undefined;
  /**
   * A tag to use for selecting assets to include in the archive. Up to 20 tags are supported.
   */
  tags?: Array<string> | undefined;
  /**
   * Select all assets where the public ID starts with this prefix. Up to 20 prefixes are supported.
   */
  prefixes?: Array<string> | undefined;
  /**
   * The specific file type of assets to include in the archive. Not applicable when "resource_type" is "all".
   */
  type?: GenerateArchiveType | undefined;
  /**
   * The transformations to apply to the assets before including them in the archive (separated by "|").
   */
  transformations?: string | undefined;
  /**
   * The method for generating and delivering the archive. Options:
   *
   * @remarks
   * download - Generates and delivers the archive file without storing it
   * create - Creates and stores the archive as a raw asset, returning URLs in the response
   * create_and_download - Creates, stores, and delivers the archive file
   */
  mode?: Mode | undefined;
  /**
   * The format of the generated archive.
   */
  targetFormat?: TargetFormat | undefined;
  /**
   * The public ID to assign to the generated archive, or the filename of the downloaded archive file.
   */
  targetPublicId?: string | undefined;
  /**
   * The folder in your product environment where the generated archive should be stored.
   */
  targetAssetFolder?: string | undefined;
  /**
   * Whether to flatten all files to be in the root of the archive file.
   */
  flattenFolders?: boolean | undefined;
  /**
   * Whether to flatten the folder structure of the derived assets.
   */
  flattenTransformations?: boolean | undefined;
  /**
   * Whether to skip adding the transformation details to the file names in the archive.
   */
  skipTransformationName?: boolean | undefined;
  /**
   * Whether to allow missing assets in the archive. If false, the operation will fail if any asset is not found.
   */
  allowMissing?: boolean | undefined;
  /**
   * ("download" mode only) Unix timestamp indicating when the generated archive URL should expire.
   */
  expiresAt?: number | undefined;
  /**
   * Whether to use the original filenames of the assets in the archive instead of public IDs (when available).
   */
  useOriginalFilename?: boolean | undefined;
  /**
   * ("create" mode only), specifies whether to generate the archive asynchronously.
   */
  async?: boolean | undefined;
  /**
   * ("create" mode only), specifies the URL to notify when the archive generation is complete.
   */
  notificationUrl?: string | undefined;
  /**
   * A list of tag names to assign to the generated archive.
   */
  targetTags?: Array<string> | undefined;
  /**
   * Whether to keep the derived assets used for generating the archive.
   */
  keepDerived?: boolean | undefined;
};

export type GenerateArchiveRequest = {
  /**
   * The type of resources to include in the archive. "image" for images, "video" for videos, "raw" for non-media files, or "all" for mixed types.
   */
  resourceType: GenerateArchiveResourceType;
  requestBody: GenerateArchiveRequestBody;
};

/**
 * Archive successfully generated or downloaded
 */
export type GenerateArchiveResponseBody = {
  /**
   * The unique identifier of the generated archive in the Cloudinary system.
   */
  assetId?: string | undefined;
  /**
   * The public ID of the generated archive.
   */
  publicId?: string | undefined;
  /**
   * The version number of the generated archive.
   */
  version?: number | undefined;
  /**
   * The unique identifier of this version of the generated archive.
   */
  versionId?: string | undefined;
  /**
   * The type of resource. Always "raw" for generated archives.
   */
  resourceType?: string | undefined;
  /**
   * The timestamp when the archive was generated.
   */
  createdAt?: Date | undefined;
  /**
   * The tags assigned to the generated archive.
   */
  tags?: Array<string> | undefined;
  /**
   * The size of the generated archive in bytes.
   */
  bytes?: number | undefined;
  /**
   * The resource type of the generated archive.
   */
  type?: string | undefined;
  /**
   * The HTTP URL for downloading the generated archive.
   */
  url?: string | undefined;
  /**
   * The HTTPS URL for downloading the generated archive.
   */
  secureUrl?: string | undefined;
  /**
   * The folder where the archive is stored (only for product environments with Dynamic Folders disabled)
   *
   * @deprecated field: If Dynamic folders mode is enabled on your product environment, this parameter is deprecated, and it's recommended to use the asset_folder parameter.
  .
   */
  folder?: string | undefined;
  /**
   * The number of unique resources included in the archive.
   */
  resourceCount?: number | undefined;
  /**
   * The total number of files in the archive.
   */
  fileCount?: number | undefined;
  /**
   * The folder in your product environment where the archive is stored.
   */
  assetFolder?: string | undefined;
  /**
   * The display name of the generated archive.
   */
  displayName?: string | undefined;
  /**
   * The list of public IDs that were requested but not found.
   */
  missingPublicIds?: Array<string> | undefined;
  /**
   * The list of tags that were requested but returned no results.
   */
  emptyTags?: Array<string> | undefined;
  /**
   * The list of prefixes that were requested but returned no results.
   */
  emptyPrefixes?: Array<string> | undefined;
};

export type GenerateArchiveResponse =
  | GenerateArchiveResponseBody
  | ReadableStream<Uint8Array>;

/** @internal */
export const GenerateArchiveGlobals$inboundSchema: z.ZodType<
  GenerateArchiveGlobals,
  z.ZodTypeDef,
  unknown
> = z.object({
  cloud_name: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "cloud_name": "cloudName",
  });
});

/** @internal */
export type GenerateArchiveGlobals$Outbound = {
  cloud_name?: string | undefined;
};

/** @internal */
export const GenerateArchiveGlobals$outboundSchema: z.ZodType<
  GenerateArchiveGlobals$Outbound,
  z.ZodTypeDef,
  GenerateArchiveGlobals
> = z.object({
  cloudName: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    cloudName: "cloud_name",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateArchiveGlobals$ {
  /** @deprecated use `GenerateArchiveGlobals$inboundSchema` instead. */
  export const inboundSchema = GenerateArchiveGlobals$inboundSchema;
  /** @deprecated use `GenerateArchiveGlobals$outboundSchema` instead. */
  export const outboundSchema = GenerateArchiveGlobals$outboundSchema;
  /** @deprecated use `GenerateArchiveGlobals$Outbound` instead. */
  export type Outbound = GenerateArchiveGlobals$Outbound;
}

export function generateArchiveGlobalsToJSON(
  generateArchiveGlobals: GenerateArchiveGlobals,
): string {
  return JSON.stringify(
    GenerateArchiveGlobals$outboundSchema.parse(generateArchiveGlobals),
  );
}

export function generateArchiveGlobalsFromJSON(
  jsonString: string,
): SafeParseResult<GenerateArchiveGlobals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateArchiveGlobals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateArchiveGlobals' from JSON`,
  );
}

/** @internal */
export const GenerateArchiveResourceType$inboundSchema: z.ZodNativeEnum<
  typeof GenerateArchiveResourceType
> = z.nativeEnum(GenerateArchiveResourceType);

/** @internal */
export const GenerateArchiveResourceType$outboundSchema: z.ZodNativeEnum<
  typeof GenerateArchiveResourceType
> = GenerateArchiveResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateArchiveResourceType$ {
  /** @deprecated use `GenerateArchiveResourceType$inboundSchema` instead. */
  export const inboundSchema = GenerateArchiveResourceType$inboundSchema;
  /** @deprecated use `GenerateArchiveResourceType$outboundSchema` instead. */
  export const outboundSchema = GenerateArchiveResourceType$outboundSchema;
}

/** @internal */
export const GenerateArchiveType$inboundSchema: z.ZodNativeEnum<
  typeof GenerateArchiveType
> = z.nativeEnum(GenerateArchiveType);

/** @internal */
export const GenerateArchiveType$outboundSchema: z.ZodNativeEnum<
  typeof GenerateArchiveType
> = GenerateArchiveType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateArchiveType$ {
  /** @deprecated use `GenerateArchiveType$inboundSchema` instead. */
  export const inboundSchema = GenerateArchiveType$inboundSchema;
  /** @deprecated use `GenerateArchiveType$outboundSchema` instead. */
  export const outboundSchema = GenerateArchiveType$outboundSchema;
}

/** @internal */
export const Mode$inboundSchema: z.ZodNativeEnum<typeof Mode> = z.nativeEnum(
  Mode,
);

/** @internal */
export const Mode$outboundSchema: z.ZodNativeEnum<typeof Mode> =
  Mode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Mode$ {
  /** @deprecated use `Mode$inboundSchema` instead. */
  export const inboundSchema = Mode$inboundSchema;
  /** @deprecated use `Mode$outboundSchema` instead. */
  export const outboundSchema = Mode$outboundSchema;
}

/** @internal */
export const TargetFormat$inboundSchema: z.ZodNativeEnum<typeof TargetFormat> =
  z.nativeEnum(TargetFormat);

/** @internal */
export const TargetFormat$outboundSchema: z.ZodNativeEnum<typeof TargetFormat> =
  TargetFormat$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TargetFormat$ {
  /** @deprecated use `TargetFormat$inboundSchema` instead. */
  export const inboundSchema = TargetFormat$inboundSchema;
  /** @deprecated use `TargetFormat$outboundSchema` instead. */
  export const outboundSchema = TargetFormat$outboundSchema;
}

/** @internal */
export const GenerateArchiveRequestBody$inboundSchema: z.ZodType<
  GenerateArchiveRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  signature: z.string().optional(),
  timestamp: z.number().int().optional(),
  api_key: z.string().optional(),
  public_ids: z.array(z.string()).optional(),
  tags: z.array(z.string()).optional(),
  prefixes: z.array(z.string()).optional(),
  type: GenerateArchiveType$inboundSchema.optional(),
  transformations: z.string().optional(),
  mode: Mode$inboundSchema.default("create"),
  target_format: TargetFormat$inboundSchema.default("zip"),
  target_public_id: z.string().optional(),
  target_asset_folder: z.string().optional(),
  flatten_folders: z.boolean().default(false),
  flatten_transformations: z.boolean().default(false),
  skip_transformation_name: z.boolean().default(false),
  allow_missing: z.boolean().default(false),
  expires_at: z.number().int().optional(),
  use_original_filename: z.boolean().default(false),
  async: z.boolean().default(false),
  notification_url: z.string().optional(),
  target_tags: z.array(z.string()).optional(),
  keep_derived: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "api_key": "apiKey",
    "public_ids": "publicIds",
    "target_format": "targetFormat",
    "target_public_id": "targetPublicId",
    "target_asset_folder": "targetAssetFolder",
    "flatten_folders": "flattenFolders",
    "flatten_transformations": "flattenTransformations",
    "skip_transformation_name": "skipTransformationName",
    "allow_missing": "allowMissing",
    "expires_at": "expiresAt",
    "use_original_filename": "useOriginalFilename",
    "notification_url": "notificationUrl",
    "target_tags": "targetTags",
    "keep_derived": "keepDerived",
  });
});

/** @internal */
export type GenerateArchiveRequestBody$Outbound = {
  signature?: string | undefined;
  timestamp?: number | undefined;
  api_key?: string | undefined;
  public_ids?: Array<string> | undefined;
  tags?: Array<string> | undefined;
  prefixes?: Array<string> | undefined;
  type?: string | undefined;
  transformations?: string | undefined;
  mode: string;
  target_format: string;
  target_public_id?: string | undefined;
  target_asset_folder?: string | undefined;
  flatten_folders: boolean;
  flatten_transformations: boolean;
  skip_transformation_name: boolean;
  allow_missing: boolean;
  expires_at?: number | undefined;
  use_original_filename: boolean;
  async: boolean;
  notification_url?: string | undefined;
  target_tags?: Array<string> | undefined;
  keep_derived: boolean;
};

/** @internal */
export const GenerateArchiveRequestBody$outboundSchema: z.ZodType<
  GenerateArchiveRequestBody$Outbound,
  z.ZodTypeDef,
  GenerateArchiveRequestBody
> = z.object({
  signature: z.string().optional(),
  timestamp: z.number().int().optional(),
  apiKey: z.string().optional(),
  publicIds: z.array(z.string()).optional(),
  tags: z.array(z.string()).optional(),
  prefixes: z.array(z.string()).optional(),
  type: GenerateArchiveType$outboundSchema.optional(),
  transformations: z.string().optional(),
  mode: Mode$outboundSchema.default("create"),
  targetFormat: TargetFormat$outboundSchema.default("zip"),
  targetPublicId: z.string().optional(),
  targetAssetFolder: z.string().optional(),
  flattenFolders: z.boolean().default(false),
  flattenTransformations: z.boolean().default(false),
  skipTransformationName: z.boolean().default(false),
  allowMissing: z.boolean().default(false),
  expiresAt: z.number().int().optional(),
  useOriginalFilename: z.boolean().default(false),
  async: z.boolean().default(false),
  notificationUrl: z.string().optional(),
  targetTags: z.array(z.string()).optional(),
  keepDerived: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    apiKey: "api_key",
    publicIds: "public_ids",
    targetFormat: "target_format",
    targetPublicId: "target_public_id",
    targetAssetFolder: "target_asset_folder",
    flattenFolders: "flatten_folders",
    flattenTransformations: "flatten_transformations",
    skipTransformationName: "skip_transformation_name",
    allowMissing: "allow_missing",
    expiresAt: "expires_at",
    useOriginalFilename: "use_original_filename",
    notificationUrl: "notification_url",
    targetTags: "target_tags",
    keepDerived: "keep_derived",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateArchiveRequestBody$ {
  /** @deprecated use `GenerateArchiveRequestBody$inboundSchema` instead. */
  export const inboundSchema = GenerateArchiveRequestBody$inboundSchema;
  /** @deprecated use `GenerateArchiveRequestBody$outboundSchema` instead. */
  export const outboundSchema = GenerateArchiveRequestBody$outboundSchema;
  /** @deprecated use `GenerateArchiveRequestBody$Outbound` instead. */
  export type Outbound = GenerateArchiveRequestBody$Outbound;
}

export function generateArchiveRequestBodyToJSON(
  generateArchiveRequestBody: GenerateArchiveRequestBody,
): string {
  return JSON.stringify(
    GenerateArchiveRequestBody$outboundSchema.parse(generateArchiveRequestBody),
  );
}

export function generateArchiveRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<GenerateArchiveRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateArchiveRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateArchiveRequestBody' from JSON`,
  );
}

/** @internal */
export const GenerateArchiveRequest$inboundSchema: z.ZodType<
  GenerateArchiveRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource_type: GenerateArchiveResourceType$inboundSchema,
  RequestBody: z.lazy(() => GenerateArchiveRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "resource_type": "resourceType",
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type GenerateArchiveRequest$Outbound = {
  resource_type: string;
  RequestBody: GenerateArchiveRequestBody$Outbound;
};

/** @internal */
export const GenerateArchiveRequest$outboundSchema: z.ZodType<
  GenerateArchiveRequest$Outbound,
  z.ZodTypeDef,
  GenerateArchiveRequest
> = z.object({
  resourceType: GenerateArchiveResourceType$outboundSchema,
  requestBody: z.lazy(() => GenerateArchiveRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    resourceType: "resource_type",
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateArchiveRequest$ {
  /** @deprecated use `GenerateArchiveRequest$inboundSchema` instead. */
  export const inboundSchema = GenerateArchiveRequest$inboundSchema;
  /** @deprecated use `GenerateArchiveRequest$outboundSchema` instead. */
  export const outboundSchema = GenerateArchiveRequest$outboundSchema;
  /** @deprecated use `GenerateArchiveRequest$Outbound` instead. */
  export type Outbound = GenerateArchiveRequest$Outbound;
}

export function generateArchiveRequestToJSON(
  generateArchiveRequest: GenerateArchiveRequest,
): string {
  return JSON.stringify(
    GenerateArchiveRequest$outboundSchema.parse(generateArchiveRequest),
  );
}

export function generateArchiveRequestFromJSON(
  jsonString: string,
): SafeParseResult<GenerateArchiveRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateArchiveRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateArchiveRequest' from JSON`,
  );
}

/** @internal */
export const GenerateArchiveResponseBody$inboundSchema: z.ZodType<
  GenerateArchiveResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  asset_id: z.string().optional(),
  public_id: z.string().optional(),
  version: z.number().int().optional(),
  version_id: z.string().optional(),
  resource_type: z.string().optional(),
  created_at: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  tags: z.array(z.string()).optional(),
  bytes: z.number().int().optional(),
  type: z.string().optional(),
  url: z.string().optional(),
  secure_url: z.string().optional(),
  folder: z.string().optional(),
  resource_count: z.number().int().optional(),
  file_count: z.number().int().optional(),
  asset_folder: z.string().optional(),
  display_name: z.string().optional(),
  missing_public_ids: z.array(z.string()).optional(),
  empty_tags: z.array(z.string()).optional(),
  empty_prefixes: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "asset_id": "assetId",
    "public_id": "publicId",
    "version_id": "versionId",
    "resource_type": "resourceType",
    "created_at": "createdAt",
    "secure_url": "secureUrl",
    "resource_count": "resourceCount",
    "file_count": "fileCount",
    "asset_folder": "assetFolder",
    "display_name": "displayName",
    "missing_public_ids": "missingPublicIds",
    "empty_tags": "emptyTags",
    "empty_prefixes": "emptyPrefixes",
  });
});

/** @internal */
export type GenerateArchiveResponseBody$Outbound = {
  asset_id?: string | undefined;
  public_id?: string | undefined;
  version?: number | undefined;
  version_id?: string | undefined;
  resource_type?: string | undefined;
  created_at?: string | undefined;
  tags?: Array<string> | undefined;
  bytes?: number | undefined;
  type?: string | undefined;
  url?: string | undefined;
  secure_url?: string | undefined;
  folder?: string | undefined;
  resource_count?: number | undefined;
  file_count?: number | undefined;
  asset_folder?: string | undefined;
  display_name?: string | undefined;
  missing_public_ids?: Array<string> | undefined;
  empty_tags?: Array<string> | undefined;
  empty_prefixes?: Array<string> | undefined;
};

/** @internal */
export const GenerateArchiveResponseBody$outboundSchema: z.ZodType<
  GenerateArchiveResponseBody$Outbound,
  z.ZodTypeDef,
  GenerateArchiveResponseBody
> = z.object({
  assetId: z.string().optional(),
  publicId: z.string().optional(),
  version: z.number().int().optional(),
  versionId: z.string().optional(),
  resourceType: z.string().optional(),
  createdAt: z.date().transform(v => v.toISOString()).optional(),
  tags: z.array(z.string()).optional(),
  bytes: z.number().int().optional(),
  type: z.string().optional(),
  url: z.string().optional(),
  secureUrl: z.string().optional(),
  folder: z.string().optional(),
  resourceCount: z.number().int().optional(),
  fileCount: z.number().int().optional(),
  assetFolder: z.string().optional(),
  displayName: z.string().optional(),
  missingPublicIds: z.array(z.string()).optional(),
  emptyTags: z.array(z.string()).optional(),
  emptyPrefixes: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    assetId: "asset_id",
    publicId: "public_id",
    versionId: "version_id",
    resourceType: "resource_type",
    createdAt: "created_at",
    secureUrl: "secure_url",
    resourceCount: "resource_count",
    fileCount: "file_count",
    assetFolder: "asset_folder",
    displayName: "display_name",
    missingPublicIds: "missing_public_ids",
    emptyTags: "empty_tags",
    emptyPrefixes: "empty_prefixes",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateArchiveResponseBody$ {
  /** @deprecated use `GenerateArchiveResponseBody$inboundSchema` instead. */
  export const inboundSchema = GenerateArchiveResponseBody$inboundSchema;
  /** @deprecated use `GenerateArchiveResponseBody$outboundSchema` instead. */
  export const outboundSchema = GenerateArchiveResponseBody$outboundSchema;
  /** @deprecated use `GenerateArchiveResponseBody$Outbound` instead. */
  export type Outbound = GenerateArchiveResponseBody$Outbound;
}

export function generateArchiveResponseBodyToJSON(
  generateArchiveResponseBody: GenerateArchiveResponseBody,
): string {
  return JSON.stringify(
    GenerateArchiveResponseBody$outboundSchema.parse(
      generateArchiveResponseBody,
    ),
  );
}

export function generateArchiveResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GenerateArchiveResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateArchiveResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateArchiveResponseBody' from JSON`,
  );
}

/** @internal */
export const GenerateArchiveResponse$inboundSchema: z.ZodType<
  GenerateArchiveResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GenerateArchiveResponseBody$inboundSchema),
  z.instanceof(ReadableStream<Uint8Array>),
]);

/** @internal */
export type GenerateArchiveResponse$Outbound =
  | GenerateArchiveResponseBody$Outbound
  | ReadableStream<Uint8Array>;

/** @internal */
export const GenerateArchiveResponse$outboundSchema: z.ZodType<
  GenerateArchiveResponse$Outbound,
  z.ZodTypeDef,
  GenerateArchiveResponse
> = z.union([
  z.lazy(() => GenerateArchiveResponseBody$outboundSchema),
  z.instanceof(ReadableStream<Uint8Array>),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateArchiveResponse$ {
  /** @deprecated use `GenerateArchiveResponse$inboundSchema` instead. */
  export const inboundSchema = GenerateArchiveResponse$inboundSchema;
  /** @deprecated use `GenerateArchiveResponse$outboundSchema` instead. */
  export const outboundSchema = GenerateArchiveResponse$outboundSchema;
  /** @deprecated use `GenerateArchiveResponse$Outbound` instead. */
  export type Outbound = GenerateArchiveResponse$Outbound;
}

export function generateArchiveResponseToJSON(
  generateArchiveResponse: GenerateArchiveResponse,
): string {
  return JSON.stringify(
    GenerateArchiveResponse$outboundSchema.parse(generateArchiveResponse),
  );
}

export function generateArchiveResponseFromJSON(
  jsonString: string,
): SafeParseResult<GenerateArchiveResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateArchiveResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateArchiveResponse' from JSON`,
  );
}
