/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type ExplodeResourceGlobals = {
  /**
   * The cloud name of your product environment.
   */
  cloudName?: string | undefined;
};

/**
 * The type of resource to explode. Only "image" is supported.
 */
export const ExplodeResourceResourceType = {
  Image: "image",
} as const;
/**
 * The type of resource to explode. Only "image" is supported.
 */
export type ExplodeResourceResourceType = ClosedEnum<
  typeof ExplodeResourceResourceType
>;

export type ExplodeResourceRequestBody = {
  /**
   * The API key to use for the request. This is automatically computed by the Cloudinary's SDKs.
   */
  apiKey?: string | undefined;
  /**
   * The timestamp to use for the request in unix time. This is automatically computed by the Cloudinary's SDKs.
   */
  timestamp?: number | undefined;
  /**
   * (Required for signed REST API calls) Used to authenticate the request and based on the parameters you use in the request. When using the Cloudinary SDKs for signed requests, the signature is automatically generated and added to the request. If you manually generate your own signed POST request, you need to manually generate the signature parameter and add it to the request together with the api_key and timestamp parameters.
   *
   * @remarks
   */
  signature?: string | undefined;
  /**
   * The public ID of the PDF or animated image to generate from.
   */
  publicId: string;
  /**
   * The format for the generated derived images. Default: png
   */
  format?: string | undefined;
  /**
   * The transformation to apply. Must contain exactly one pg_all transformation parameter.
   */
  transformation: string;
  /**
   * The webhook URL to notify when the operation is complete.
   */
  notificationUrl?: string | undefined;
  /**
   * The storage type of the resource.
   */
  type?: components.StorageType | undefined;
};

export type ExplodeResourceRequest = {
  /**
   * The type of resource to explode. Only "image" is supported.
   */
  resourceType: ExplodeResourceResourceType;
  requestBody: ExplodeResourceRequestBody;
};

/**
 * The status of the explode operation.
 */
export const Status = {
  Processing: "processing",
} as const;
/**
 * The status of the explode operation.
 */
export type Status = ClosedEnum<typeof Status>;

/**
 * Explode operation started successfully
 */
export type ExplodeResourceResponse = {
  /**
   * The status of the explode operation.
   */
  status?: Status | undefined;
  /**
   * The ID of the batch operation.
   */
  batchId?: string | undefined;
};

/** @internal */
export const ExplodeResourceGlobals$inboundSchema: z.ZodType<
  ExplodeResourceGlobals,
  z.ZodTypeDef,
  unknown
> = z.object({
  cloud_name: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "cloud_name": "cloudName",
  });
});

/** @internal */
export type ExplodeResourceGlobals$Outbound = {
  cloud_name?: string | undefined;
};

/** @internal */
export const ExplodeResourceGlobals$outboundSchema: z.ZodType<
  ExplodeResourceGlobals$Outbound,
  z.ZodTypeDef,
  ExplodeResourceGlobals
> = z.object({
  cloudName: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    cloudName: "cloud_name",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExplodeResourceGlobals$ {
  /** @deprecated use `ExplodeResourceGlobals$inboundSchema` instead. */
  export const inboundSchema = ExplodeResourceGlobals$inboundSchema;
  /** @deprecated use `ExplodeResourceGlobals$outboundSchema` instead. */
  export const outboundSchema = ExplodeResourceGlobals$outboundSchema;
  /** @deprecated use `ExplodeResourceGlobals$Outbound` instead. */
  export type Outbound = ExplodeResourceGlobals$Outbound;
}

export function explodeResourceGlobalsToJSON(
  explodeResourceGlobals: ExplodeResourceGlobals,
): string {
  return JSON.stringify(
    ExplodeResourceGlobals$outboundSchema.parse(explodeResourceGlobals),
  );
}

export function explodeResourceGlobalsFromJSON(
  jsonString: string,
): SafeParseResult<ExplodeResourceGlobals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExplodeResourceGlobals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExplodeResourceGlobals' from JSON`,
  );
}

/** @internal */
export const ExplodeResourceResourceType$inboundSchema: z.ZodNativeEnum<
  typeof ExplodeResourceResourceType
> = z.nativeEnum(ExplodeResourceResourceType);

/** @internal */
export const ExplodeResourceResourceType$outboundSchema: z.ZodNativeEnum<
  typeof ExplodeResourceResourceType
> = ExplodeResourceResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExplodeResourceResourceType$ {
  /** @deprecated use `ExplodeResourceResourceType$inboundSchema` instead. */
  export const inboundSchema = ExplodeResourceResourceType$inboundSchema;
  /** @deprecated use `ExplodeResourceResourceType$outboundSchema` instead. */
  export const outboundSchema = ExplodeResourceResourceType$outboundSchema;
}

/** @internal */
export const ExplodeResourceRequestBody$inboundSchema: z.ZodType<
  ExplodeResourceRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  api_key: z.string().optional(),
  timestamp: z.number().int().optional(),
  signature: z.string().optional(),
  public_id: z.string(),
  format: z.string().optional(),
  transformation: z.string(),
  notification_url: z.string().optional(),
  type: components.StorageType$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "api_key": "apiKey",
    "public_id": "publicId",
    "notification_url": "notificationUrl",
  });
});

/** @internal */
export type ExplodeResourceRequestBody$Outbound = {
  api_key?: string | undefined;
  timestamp?: number | undefined;
  signature?: string | undefined;
  public_id: string;
  format?: string | undefined;
  transformation: string;
  notification_url?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const ExplodeResourceRequestBody$outboundSchema: z.ZodType<
  ExplodeResourceRequestBody$Outbound,
  z.ZodTypeDef,
  ExplodeResourceRequestBody
> = z.object({
  apiKey: z.string().optional(),
  timestamp: z.number().int().optional(),
  signature: z.string().optional(),
  publicId: z.string(),
  format: z.string().optional(),
  transformation: z.string(),
  notificationUrl: z.string().optional(),
  type: components.StorageType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    apiKey: "api_key",
    publicId: "public_id",
    notificationUrl: "notification_url",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExplodeResourceRequestBody$ {
  /** @deprecated use `ExplodeResourceRequestBody$inboundSchema` instead. */
  export const inboundSchema = ExplodeResourceRequestBody$inboundSchema;
  /** @deprecated use `ExplodeResourceRequestBody$outboundSchema` instead. */
  export const outboundSchema = ExplodeResourceRequestBody$outboundSchema;
  /** @deprecated use `ExplodeResourceRequestBody$Outbound` instead. */
  export type Outbound = ExplodeResourceRequestBody$Outbound;
}

export function explodeResourceRequestBodyToJSON(
  explodeResourceRequestBody: ExplodeResourceRequestBody,
): string {
  return JSON.stringify(
    ExplodeResourceRequestBody$outboundSchema.parse(explodeResourceRequestBody),
  );
}

export function explodeResourceRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<ExplodeResourceRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExplodeResourceRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExplodeResourceRequestBody' from JSON`,
  );
}

/** @internal */
export const ExplodeResourceRequest$inboundSchema: z.ZodType<
  ExplodeResourceRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource_type: ExplodeResourceResourceType$inboundSchema,
  RequestBody: z.lazy(() => ExplodeResourceRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "resource_type": "resourceType",
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type ExplodeResourceRequest$Outbound = {
  resource_type: string;
  RequestBody: ExplodeResourceRequestBody$Outbound;
};

/** @internal */
export const ExplodeResourceRequest$outboundSchema: z.ZodType<
  ExplodeResourceRequest$Outbound,
  z.ZodTypeDef,
  ExplodeResourceRequest
> = z.object({
  resourceType: ExplodeResourceResourceType$outboundSchema,
  requestBody: z.lazy(() => ExplodeResourceRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    resourceType: "resource_type",
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExplodeResourceRequest$ {
  /** @deprecated use `ExplodeResourceRequest$inboundSchema` instead. */
  export const inboundSchema = ExplodeResourceRequest$inboundSchema;
  /** @deprecated use `ExplodeResourceRequest$outboundSchema` instead. */
  export const outboundSchema = ExplodeResourceRequest$outboundSchema;
  /** @deprecated use `ExplodeResourceRequest$Outbound` instead. */
  export type Outbound = ExplodeResourceRequest$Outbound;
}

export function explodeResourceRequestToJSON(
  explodeResourceRequest: ExplodeResourceRequest,
): string {
  return JSON.stringify(
    ExplodeResourceRequest$outboundSchema.parse(explodeResourceRequest),
  );
}

export function explodeResourceRequestFromJSON(
  jsonString: string,
): SafeParseResult<ExplodeResourceRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExplodeResourceRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExplodeResourceRequest' from JSON`,
  );
}

/** @internal */
export const Status$inboundSchema: z.ZodNativeEnum<typeof Status> = z
  .nativeEnum(Status);

/** @internal */
export const Status$outboundSchema: z.ZodNativeEnum<typeof Status> =
  Status$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Status$ {
  /** @deprecated use `Status$inboundSchema` instead. */
  export const inboundSchema = Status$inboundSchema;
  /** @deprecated use `Status$outboundSchema` instead. */
  export const outboundSchema = Status$outboundSchema;
}

/** @internal */
export const ExplodeResourceResponse$inboundSchema: z.ZodType<
  ExplodeResourceResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  status: Status$inboundSchema.optional(),
  batch_id: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "batch_id": "batchId",
  });
});

/** @internal */
export type ExplodeResourceResponse$Outbound = {
  status?: string | undefined;
  batch_id?: string | undefined;
};

/** @internal */
export const ExplodeResourceResponse$outboundSchema: z.ZodType<
  ExplodeResourceResponse$Outbound,
  z.ZodTypeDef,
  ExplodeResourceResponse
> = z.object({
  status: Status$outboundSchema.optional(),
  batchId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    batchId: "batch_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExplodeResourceResponse$ {
  /** @deprecated use `ExplodeResourceResponse$inboundSchema` instead. */
  export const inboundSchema = ExplodeResourceResponse$inboundSchema;
  /** @deprecated use `ExplodeResourceResponse$outboundSchema` instead. */
  export const outboundSchema = ExplodeResourceResponse$outboundSchema;
  /** @deprecated use `ExplodeResourceResponse$Outbound` instead. */
  export type Outbound = ExplodeResourceResponse$Outbound;
}

export function explodeResourceResponseToJSON(
  explodeResourceResponse: ExplodeResourceResponse,
): string {
  return JSON.stringify(
    ExplodeResourceResponse$outboundSchema.parse(explodeResourceResponse),
  );
}

export function explodeResourceResponseFromJSON(
  jsonString: string,
): SafeParseResult<ExplodeResourceResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExplodeResourceResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExplodeResourceResponse' from JSON`,
  );
}
