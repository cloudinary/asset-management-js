/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type DownloadBackupAssetGlobals = {
  /**
   * The cloud name of your product environment.
   */
  cloudName?: string | undefined;
};

export type DownloadBackupAssetRequest = {
  /**
   * The asset ID of the resource. Must be a 32-character hexadecimal string.
   */
  assetId: string;
  /**
   * The version ID of the backup to download. Must be a 32-character hexadecimal string.
   */
  versionId: string;
  /**
   * The API key to use for the request. This is automatically computed by the Cloudinary's SDKs.
   */
  apiKey?: string | undefined;
  /**
   * (Required for signed REST API calls) Used to authenticate the request and based on the parameters you use in the request. When using the Cloudinary SDKs for signed requests, the signature is automatically generated and added to the request. If you manually generate your own signed POST request, you need to manually generate the signature parameter and add it to the request together with the api_key and timestamp parameters.
   *
   * @remarks
   */
  signature?: string | undefined;
  /**
   * The timestamp to use for the request in unix time. This is automatically computed by the Cloudinary's SDKs.
   */
  timestamp?: number | undefined;
};

export type NotFoundError = {
  /**
   * Specified version does not exist
   */
  message?: string | undefined;
};

export type DownloadBackupAssetUnauthorizedError = {
  /**
   * Invalid Signature or timestamp expired.
   */
  message?: string | undefined;
  /**
   * The HTTP status code.
   */
  httpCode?: number | undefined;
};

export type BadRequestError = {
  /**
   * A problem with one of the parameters or timestamp.
   */
  message?: string | undefined;
  /**
   * The HTTP status code.
   */
  httpCode?: number | undefined;
};

export type DownloadBackupAssetResponse =
  | ReadableStream<Uint8Array>
  | ReadableStream<Uint8Array>
  | ReadableStream<Uint8Array>
  | ReadableStream<Uint8Array>;

/** @internal */
export const DownloadBackupAssetGlobals$inboundSchema: z.ZodType<
  DownloadBackupAssetGlobals,
  z.ZodTypeDef,
  unknown
> = z.object({
  cloud_name: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "cloud_name": "cloudName",
  });
});

/** @internal */
export type DownloadBackupAssetGlobals$Outbound = {
  cloud_name?: string | undefined;
};

/** @internal */
export const DownloadBackupAssetGlobals$outboundSchema: z.ZodType<
  DownloadBackupAssetGlobals$Outbound,
  z.ZodTypeDef,
  DownloadBackupAssetGlobals
> = z.object({
  cloudName: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    cloudName: "cloud_name",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DownloadBackupAssetGlobals$ {
  /** @deprecated use `DownloadBackupAssetGlobals$inboundSchema` instead. */
  export const inboundSchema = DownloadBackupAssetGlobals$inboundSchema;
  /** @deprecated use `DownloadBackupAssetGlobals$outboundSchema` instead. */
  export const outboundSchema = DownloadBackupAssetGlobals$outboundSchema;
  /** @deprecated use `DownloadBackupAssetGlobals$Outbound` instead. */
  export type Outbound = DownloadBackupAssetGlobals$Outbound;
}

export function downloadBackupAssetGlobalsToJSON(
  downloadBackupAssetGlobals: DownloadBackupAssetGlobals,
): string {
  return JSON.stringify(
    DownloadBackupAssetGlobals$outboundSchema.parse(downloadBackupAssetGlobals),
  );
}

export function downloadBackupAssetGlobalsFromJSON(
  jsonString: string,
): SafeParseResult<DownloadBackupAssetGlobals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DownloadBackupAssetGlobals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DownloadBackupAssetGlobals' from JSON`,
  );
}

/** @internal */
export const DownloadBackupAssetRequest$inboundSchema: z.ZodType<
  DownloadBackupAssetRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  asset_id: z.string(),
  version_id: z.string(),
  api_key: z.string().optional(),
  signature: z.string().optional(),
  timestamp: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    "asset_id": "assetId",
    "version_id": "versionId",
    "api_key": "apiKey",
  });
});

/** @internal */
export type DownloadBackupAssetRequest$Outbound = {
  asset_id: string;
  version_id: string;
  api_key?: string | undefined;
  signature?: string | undefined;
  timestamp?: number | undefined;
};

/** @internal */
export const DownloadBackupAssetRequest$outboundSchema: z.ZodType<
  DownloadBackupAssetRequest$Outbound,
  z.ZodTypeDef,
  DownloadBackupAssetRequest
> = z.object({
  assetId: z.string(),
  versionId: z.string(),
  apiKey: z.string().optional(),
  signature: z.string().optional(),
  timestamp: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    assetId: "asset_id",
    versionId: "version_id",
    apiKey: "api_key",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DownloadBackupAssetRequest$ {
  /** @deprecated use `DownloadBackupAssetRequest$inboundSchema` instead. */
  export const inboundSchema = DownloadBackupAssetRequest$inboundSchema;
  /** @deprecated use `DownloadBackupAssetRequest$outboundSchema` instead. */
  export const outboundSchema = DownloadBackupAssetRequest$outboundSchema;
  /** @deprecated use `DownloadBackupAssetRequest$Outbound` instead. */
  export type Outbound = DownloadBackupAssetRequest$Outbound;
}

export function downloadBackupAssetRequestToJSON(
  downloadBackupAssetRequest: DownloadBackupAssetRequest,
): string {
  return JSON.stringify(
    DownloadBackupAssetRequest$outboundSchema.parse(downloadBackupAssetRequest),
  );
}

export function downloadBackupAssetRequestFromJSON(
  jsonString: string,
): SafeParseResult<DownloadBackupAssetRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DownloadBackupAssetRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DownloadBackupAssetRequest' from JSON`,
  );
}

/** @internal */
export const NotFoundError$inboundSchema: z.ZodType<
  NotFoundError,
  z.ZodTypeDef,
  unknown
> = z.object({
  message: z.string().optional(),
});

/** @internal */
export type NotFoundError$Outbound = {
  message?: string | undefined;
};

/** @internal */
export const NotFoundError$outboundSchema: z.ZodType<
  NotFoundError$Outbound,
  z.ZodTypeDef,
  NotFoundError
> = z.object({
  message: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotFoundError$ {
  /** @deprecated use `NotFoundError$inboundSchema` instead. */
  export const inboundSchema = NotFoundError$inboundSchema;
  /** @deprecated use `NotFoundError$outboundSchema` instead. */
  export const outboundSchema = NotFoundError$outboundSchema;
  /** @deprecated use `NotFoundError$Outbound` instead. */
  export type Outbound = NotFoundError$Outbound;
}

export function notFoundErrorToJSON(notFoundError: NotFoundError): string {
  return JSON.stringify(NotFoundError$outboundSchema.parse(notFoundError));
}

export function notFoundErrorFromJSON(
  jsonString: string,
): SafeParseResult<NotFoundError, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotFoundError$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotFoundError' from JSON`,
  );
}

/** @internal */
export const DownloadBackupAssetUnauthorizedError$inboundSchema: z.ZodType<
  DownloadBackupAssetUnauthorizedError,
  z.ZodTypeDef,
  unknown
> = z.object({
  message: z.string().optional(),
  http_code: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    "http_code": "httpCode",
  });
});

/** @internal */
export type DownloadBackupAssetUnauthorizedError$Outbound = {
  message?: string | undefined;
  http_code?: number | undefined;
};

/** @internal */
export const DownloadBackupAssetUnauthorizedError$outboundSchema: z.ZodType<
  DownloadBackupAssetUnauthorizedError$Outbound,
  z.ZodTypeDef,
  DownloadBackupAssetUnauthorizedError
> = z.object({
  message: z.string().optional(),
  httpCode: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    httpCode: "http_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DownloadBackupAssetUnauthorizedError$ {
  /** @deprecated use `DownloadBackupAssetUnauthorizedError$inboundSchema` instead. */
  export const inboundSchema =
    DownloadBackupAssetUnauthorizedError$inboundSchema;
  /** @deprecated use `DownloadBackupAssetUnauthorizedError$outboundSchema` instead. */
  export const outboundSchema =
    DownloadBackupAssetUnauthorizedError$outboundSchema;
  /** @deprecated use `DownloadBackupAssetUnauthorizedError$Outbound` instead. */
  export type Outbound = DownloadBackupAssetUnauthorizedError$Outbound;
}

export function downloadBackupAssetUnauthorizedErrorToJSON(
  downloadBackupAssetUnauthorizedError: DownloadBackupAssetUnauthorizedError,
): string {
  return JSON.stringify(
    DownloadBackupAssetUnauthorizedError$outboundSchema.parse(
      downloadBackupAssetUnauthorizedError,
    ),
  );
}

export function downloadBackupAssetUnauthorizedErrorFromJSON(
  jsonString: string,
): SafeParseResult<DownloadBackupAssetUnauthorizedError, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DownloadBackupAssetUnauthorizedError$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DownloadBackupAssetUnauthorizedError' from JSON`,
  );
}

/** @internal */
export const BadRequestError$inboundSchema: z.ZodType<
  BadRequestError,
  z.ZodTypeDef,
  unknown
> = z.object({
  message: z.string().optional(),
  http_code: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    "http_code": "httpCode",
  });
});

/** @internal */
export type BadRequestError$Outbound = {
  message?: string | undefined;
  http_code?: number | undefined;
};

/** @internal */
export const BadRequestError$outboundSchema: z.ZodType<
  BadRequestError$Outbound,
  z.ZodTypeDef,
  BadRequestError
> = z.object({
  message: z.string().optional(),
  httpCode: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    httpCode: "http_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BadRequestError$ {
  /** @deprecated use `BadRequestError$inboundSchema` instead. */
  export const inboundSchema = BadRequestError$inboundSchema;
  /** @deprecated use `BadRequestError$outboundSchema` instead. */
  export const outboundSchema = BadRequestError$outboundSchema;
  /** @deprecated use `BadRequestError$Outbound` instead. */
  export type Outbound = BadRequestError$Outbound;
}

export function badRequestErrorToJSON(
  badRequestError: BadRequestError,
): string {
  return JSON.stringify(BadRequestError$outboundSchema.parse(badRequestError));
}

export function badRequestErrorFromJSON(
  jsonString: string,
): SafeParseResult<BadRequestError, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BadRequestError$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BadRequestError' from JSON`,
  );
}

/** @internal */
export const DownloadBackupAssetResponse$inboundSchema: z.ZodType<
  DownloadBackupAssetResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.instanceof(ReadableStream<Uint8Array>),
  z.instanceof(ReadableStream<Uint8Array>),
  z.instanceof(ReadableStream<Uint8Array>),
  z.instanceof(ReadableStream<Uint8Array>),
]);

/** @internal */
export type DownloadBackupAssetResponse$Outbound =
  | ReadableStream<Uint8Array>
  | ReadableStream<Uint8Array>
  | ReadableStream<Uint8Array>
  | ReadableStream<Uint8Array>;

/** @internal */
export const DownloadBackupAssetResponse$outboundSchema: z.ZodType<
  DownloadBackupAssetResponse$Outbound,
  z.ZodTypeDef,
  DownloadBackupAssetResponse
> = z.union([
  z.instanceof(ReadableStream<Uint8Array>),
  z.instanceof(ReadableStream<Uint8Array>),
  z.instanceof(ReadableStream<Uint8Array>),
  z.instanceof(ReadableStream<Uint8Array>),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DownloadBackupAssetResponse$ {
  /** @deprecated use `DownloadBackupAssetResponse$inboundSchema` instead. */
  export const inboundSchema = DownloadBackupAssetResponse$inboundSchema;
  /** @deprecated use `DownloadBackupAssetResponse$outboundSchema` instead. */
  export const outboundSchema = DownloadBackupAssetResponse$outboundSchema;
  /** @deprecated use `DownloadBackupAssetResponse$Outbound` instead. */
  export type Outbound = DownloadBackupAssetResponse$Outbound;
}

export function downloadBackupAssetResponseToJSON(
  downloadBackupAssetResponse: DownloadBackupAssetResponse,
): string {
  return JSON.stringify(
    DownloadBackupAssetResponse$outboundSchema.parse(
      downloadBackupAssetResponse,
    ),
  );
}

export function downloadBackupAssetResponseFromJSON(
  jsonString: string,
): SafeParseResult<DownloadBackupAssetResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DownloadBackupAssetResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DownloadBackupAssetResponse' from JSON`,
  );
}
