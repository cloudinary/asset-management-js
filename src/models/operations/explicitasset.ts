/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type ExplicitAssetGlobals = {
  /**
   * The cloud name of your product environment.
   */
  cloudName?: string | undefined;
};

/**
 * The type of resource to apply operations on. "image" for images, "video" for videos, or "raw" for non-media files.
 */
export const ExplicitAssetResourceType = {
  Image: "image",
  Video: "video",
  Raw: "raw",
} as const;
/**
 * The type of resource to apply operations on. "image" for images, "video" for videos, or "raw" for non-media files.
 */
export type ExplicitAssetResourceType = ClosedEnum<
  typeof ExplicitAssetResourceType
>;

/**
 * For all asset types, set to:
 *
 * @remarks
 * - manual to add the uploaded asset to a list of pending assets that can be moderated using the Admin API or the Cloudinary Console.
 * - perception_point to automatically moderate the uploaded asset using the Perception Point Malware Detection add-on.
 *
 * For images only, set to:
 * - webpurify to automatically moderate the uploaded image using the WebPurify Image Moderation add-on.
 * - aws_rek to automatically moderate the uploaded image using the Amazon Rekognition AI Moderation add-on.
 * - duplicate:<threshold> to detect if the same or a similar image already exists using the Cloudinary Duplicate Image Detection add-on. Set threshold to a float greater than 0 and less than or equal to 1.0 to specify how similar an image needs to be in order to be considered a duplicate. Set threshold to 0 to add an image to the index of images that are searched when duplicate detection is invoked for another image.
 *
 * For videos only, set to:
 * - aws_rek_video to automatically moderate the uploaded video using the Amazon Rekognition Video Moderation add-on.
 * - google_video_moderation automatically moderate the uploaded video using the Google AI Video Moderation add-on.
 *
 * To request multiple moderations in a single API call:
 * - Send the desired list of moderations as a pipe-separated string with manual moderation, if relevant, being last.
 *
 * Note: Rejected assets are automatically invalidated on the CDN within approximately ten minutes.
 */
export const ExplicitAssetModeration = {
  Manual: "manual",
  Webpurify: "webpurify",
  Metascan: "metascan",
  AwsRek: "aws_rek",
  AwsRekVideo: "aws_rek_video",
  GoogleVideoModeration: "google_video_moderation",
  PerceptionPoint: "perception_point",
  Duplicate: "duplicate",
  Cld: "cld",
} as const;
/**
 * For all asset types, set to:
 *
 * @remarks
 * - manual to add the uploaded asset to a list of pending assets that can be moderated using the Admin API or the Cloudinary Console.
 * - perception_point to automatically moderate the uploaded asset using the Perception Point Malware Detection add-on.
 *
 * For images only, set to:
 * - webpurify to automatically moderate the uploaded image using the WebPurify Image Moderation add-on.
 * - aws_rek to automatically moderate the uploaded image using the Amazon Rekognition AI Moderation add-on.
 * - duplicate:<threshold> to detect if the same or a similar image already exists using the Cloudinary Duplicate Image Detection add-on. Set threshold to a float greater than 0 and less than or equal to 1.0 to specify how similar an image needs to be in order to be considered a duplicate. Set threshold to 0 to add an image to the index of images that are searched when duplicate detection is invoked for another image.
 *
 * For videos only, set to:
 * - aws_rek_video to automatically moderate the uploaded video using the Amazon Rekognition Video Moderation add-on.
 * - google_video_moderation automatically moderate the uploaded video using the Google AI Video Moderation add-on.
 *
 * To request multiple moderations in a single API call:
 * - Send the desired list of moderations as a pipe-separated string with manual moderation, if relevant, being last.
 *
 * Note: Rejected assets are automatically invalidated on the CDN within approximately ten minutes.
 */
export type ExplicitAssetModeration = ClosedEnum<
  typeof ExplicitAssetModeration
>;

export type ResponsiveBreakpoint = {
  createDerived?: boolean | undefined;
  maxWidth?: number | undefined;
  minWidth?: number | undefined;
  bytesStep?: number | undefined;
  maxImages?: number | undefined;
  transformation?: string | undefined;
};

/**
 * The storage type of the asset. Defaults to 'upload'.
 */
export const ExplicitAssetType = {
  Upload: "upload",
  Private: "private",
  Authenticated: "authenticated",
  Fetch: "fetch",
} as const;
/**
 * The storage type of the asset. Defaults to 'upload'.
 */
export type ExplicitAssetType = ClosedEnum<typeof ExplicitAssetType>;

/**
 * Override the quality setting for this asset.
 */
export type QualityOverride = string | number;

export type ExplicitAssetRequestBody = {
  /**
   * (Required for signed REST API calls) Used to authenticate the request and based on the parameters you use in the request. When using the Cloudinary SDKs for signed requests, the signature is automatically generated and added to the request. If you manually generate your own signed POST request, you need to manually generate the signature parameter and add it to the request together with the api_key and timestamp parameters.
   *
   * @remarks
   */
  signature?: string | undefined;
  /**
   * The timestamp to use for the request in unix time. This is automatically computed by the Cloudinary's SDKs.
   */
  timestamp?: number | undefined;
  /**
   * The API key to use for the request. This is automatically computed by the Cloudinary's SDKs.
   */
  apiKey?: string | undefined;
  /**
   * Whether to return return accessibility analysis values for the image.
   */
  accessibilityAnalysis?: boolean | undefined;
  /**
   * The asset folder to assign to the asset.
   */
  assetFolder?: string | undefined;
  /**
   * When set to true, returns the uploaded asset's public_id immediately in the response, before the upload is completed (asynchronously). Default: false.
   *
   * @remarks
   */
  async?: boolean | undefined;
  /**
   * Whether to trigger automatic generation of video chapters. Chapters will be generated and saved as a .vtt file with -chapters appended to the public ID of the video. You can enable chapters as part of the Cloudinary Video Player. Relevant for videos only.
   */
  autoChaptering?: boolean | undefined;
  /**
   * Whether to trigger automatic generation of video transcription. Transcription will be generated and saved as a .vtt file with -transcription appended to the public ID of the video. Relevant for videos only.
   */
  autoTranscription?: boolean | undefined;
  /**
   * Whether to return a cinemagraph analysis value for the media asset between 0 and 1, where 0 means the asset is not a cinemagraph and 1 means the asset is a cinemagraph. Relevant for animated images and video only. A static image will return 0.
   */
  cinemagraphAnalysis?: boolean | undefined;
  /**
   * Whether to retrieve predominant colors & color histogram of the uploaded image. Note: If all returned colors are opaque, then 6-digit RGB hex values are returned. If one or more colors contain an alpha channel, then 8-digit RGBA hex quadruplet values are returned.
   */
  colors?: boolean | undefined;
  /**
   * Key-value pairs of general textual context metadata to attach to the asset.
   */
  context?: string | undefined;
  /**
   * An array of coordinates for custom cropping.
   */
  customCoordinates?: string | undefined;
  /**
   * A display name for the asset.
   */
  displayName?: string | undefined;
  /**
   * A list of transformations to eagerly generate for the asset. Accepts either a single transformation or a pipe-separated list of transformations.
   */
  eager?: string | undefined;
  /**
   * Whether to generate the eager transformations asynchronously in the background after the upload request is completed rather than before the upload is completed.
   */
  eagerAsync?: boolean | undefined;
  /**
   * A URL to notify when eager transformations are completed.
   */
  eagerNotificationUrl?: string | undefined;
  /**
   * An array of coordinates representing detected faces in the asset, used for custom cropping or overlays.
   */
  faceCoordinates?: string | undefined;
  /**
   * Whether to detect faces in the asset.
   */
  faces?: boolean | undefined;
  /**
   * An HTTP header or a list of headers lines for adding as response HTTP headers when delivering the asset to your users. Supported headers: Link, Authorization, X-Robots-Tag.
   *
   * @remarks
   */
  headers?: string | undefined;
  /**
   * Whether to invalidate CDN cache copies of a previously uploaded asset that shares the same public ID. Default: false.
   *
   * @remarks
   */
  invalidate?: boolean | undefined;
  /**
   * Whether to return IPTC, XMP, and detailed Exif metadata of the uploaded asset in the response.
   *
   * @remarks
   * Supported for images, video, and audio.
   * - Returned metadata for images includes: PixelsPerUnitX, PixelsPerUnitY, PixelUnits, Colorspace, and DPI.
   * - Returned metadata for audio and video includes: audio_codec, audio_bit_rate, audio_frequency, channels, channel_layout.
   * - Additional metadata for video includes: pix_format, codec, level, profile, video_bit_rate, dar.
   */
  mediaMetadata?: boolean | undefined;
  /**
   * Structured metadata to attach to the asset based on the metadata fields defined for your account.
   */
  metadata?: string | undefined;
  /**
   * For all asset types, set to:
   *
   * @remarks
   * - manual to add the uploaded asset to a list of pending assets that can be moderated using the Admin API or the Cloudinary Console.
   * - perception_point to automatically moderate the uploaded asset using the Perception Point Malware Detection add-on.
   *
   * For images only, set to:
   * - webpurify to automatically moderate the uploaded image using the WebPurify Image Moderation add-on.
   * - aws_rek to automatically moderate the uploaded image using the Amazon Rekognition AI Moderation add-on.
   * - duplicate:<threshold> to detect if the same or a similar image already exists using the Cloudinary Duplicate Image Detection add-on. Set threshold to a float greater than 0 and less than or equal to 1.0 to specify how similar an image needs to be in order to be considered a duplicate. Set threshold to 0 to add an image to the index of images that are searched when duplicate detection is invoked for another image.
   *
   * For videos only, set to:
   * - aws_rek_video to automatically moderate the uploaded video using the Amazon Rekognition Video Moderation add-on.
   * - google_video_moderation automatically moderate the uploaded video using the Google AI Video Moderation add-on.
   *
   * To request multiple moderations in a single API call:
   * - Send the desired list of moderations as a pipe-separated string with manual moderation, if relevant, being last.
   *
   * Note: Rejected assets are automatically invalidated on the CDN within approximately ten minutes.
   */
  moderation?: ExplicitAssetModeration | undefined;
  /**
   * A URL to notify when the asset is ready.
   */
  notificationUrl?: string | undefined;
  /**
   * Whether to return the perceptual hash (pHash) on the uploaded image for image similarity detection.
   *
   * @remarks
   */
  phash?: boolean | undefined;
  /**
   * Whether to return a quality analysis value for the image between 0 and 1, where 0 means the image is blurry and out of focus and 1 means the image is sharp and in focus. Relevant for images only.
   */
  qualityAnalysis?: boolean | undefined;
  /**
   * Regions to detect in the asset.
   */
  regions?: string | undefined;
  /**
   * Settings to automatically generate breakpoints for responsive images.
   */
  responsiveBreakpoints?: Array<ResponsiveBreakpoint> | undefined;
  /**
   * A comma-separated list of tag names to assign to the asset.
   */
  tags?: string | undefined;
  /**
   * A URL to redirect to after the upload/explicit is completed instead of returning the upload response.
   *
   * @remarks
   * Signed upload result parameters are added to the callback URL. This parameter is ignored for XHR (Ajax XMLHttpRequest) or JavaScript Fetch API upload requests.
   * Note: This parameter is relevant for direct uploads from a form in the browser. It is automatically set if you perform direct upload from the browser using Cloudinary's SDKs and the jQuery plugin.
   */
  callback?: string | undefined;
  /**
   * The public ID of the existing asset to apply operations on.
   */
  publicId: string;
  /**
   * The storage type of the asset. Defaults to 'upload'.
   */
  type?: ExplicitAssetType | undefined;
  /**
   * When applying eager for already existing video transformations, this setting indicates whether to force the existing derived video resources to be regenerated. Default for videos: false.
   *
   * @remarks
   * Note: When specifying existing eager transformations for images, corresponding derived images are always regenerated.
   */
  overwrite?: boolean | undefined;
  /**
   * Override the quality setting for this asset.
   */
  qualityOverride?: string | number | undefined;
};

export type ExplicitAssetRequest = {
  /**
   * The type of resource to apply operations on. "image" for images, "video" for videos, or "raw" for non-media files.
   */
  resourceType: ExplicitAssetResourceType;
  requestBody: ExplicitAssetRequestBody;
};

/** @internal */
export const ExplicitAssetGlobals$inboundSchema: z.ZodType<
  ExplicitAssetGlobals,
  z.ZodTypeDef,
  unknown
> = z.object({
  cloud_name: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "cloud_name": "cloudName",
  });
});

/** @internal */
export type ExplicitAssetGlobals$Outbound = {
  cloud_name?: string | undefined;
};

/** @internal */
export const ExplicitAssetGlobals$outboundSchema: z.ZodType<
  ExplicitAssetGlobals$Outbound,
  z.ZodTypeDef,
  ExplicitAssetGlobals
> = z.object({
  cloudName: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    cloudName: "cloud_name",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExplicitAssetGlobals$ {
  /** @deprecated use `ExplicitAssetGlobals$inboundSchema` instead. */
  export const inboundSchema = ExplicitAssetGlobals$inboundSchema;
  /** @deprecated use `ExplicitAssetGlobals$outboundSchema` instead. */
  export const outboundSchema = ExplicitAssetGlobals$outboundSchema;
  /** @deprecated use `ExplicitAssetGlobals$Outbound` instead. */
  export type Outbound = ExplicitAssetGlobals$Outbound;
}

export function explicitAssetGlobalsToJSON(
  explicitAssetGlobals: ExplicitAssetGlobals,
): string {
  return JSON.stringify(
    ExplicitAssetGlobals$outboundSchema.parse(explicitAssetGlobals),
  );
}

export function explicitAssetGlobalsFromJSON(
  jsonString: string,
): SafeParseResult<ExplicitAssetGlobals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExplicitAssetGlobals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExplicitAssetGlobals' from JSON`,
  );
}

/** @internal */
export const ExplicitAssetResourceType$inboundSchema: z.ZodNativeEnum<
  typeof ExplicitAssetResourceType
> = z.nativeEnum(ExplicitAssetResourceType);

/** @internal */
export const ExplicitAssetResourceType$outboundSchema: z.ZodNativeEnum<
  typeof ExplicitAssetResourceType
> = ExplicitAssetResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExplicitAssetResourceType$ {
  /** @deprecated use `ExplicitAssetResourceType$inboundSchema` instead. */
  export const inboundSchema = ExplicitAssetResourceType$inboundSchema;
  /** @deprecated use `ExplicitAssetResourceType$outboundSchema` instead. */
  export const outboundSchema = ExplicitAssetResourceType$outboundSchema;
}

/** @internal */
export const ExplicitAssetModeration$inboundSchema: z.ZodNativeEnum<
  typeof ExplicitAssetModeration
> = z.nativeEnum(ExplicitAssetModeration);

/** @internal */
export const ExplicitAssetModeration$outboundSchema: z.ZodNativeEnum<
  typeof ExplicitAssetModeration
> = ExplicitAssetModeration$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExplicitAssetModeration$ {
  /** @deprecated use `ExplicitAssetModeration$inboundSchema` instead. */
  export const inboundSchema = ExplicitAssetModeration$inboundSchema;
  /** @deprecated use `ExplicitAssetModeration$outboundSchema` instead. */
  export const outboundSchema = ExplicitAssetModeration$outboundSchema;
}

/** @internal */
export const ResponsiveBreakpoint$inboundSchema: z.ZodType<
  ResponsiveBreakpoint,
  z.ZodTypeDef,
  unknown
> = z.object({
  create_derived: z.boolean().optional(),
  max_width: z.number().int().optional(),
  min_width: z.number().int().optional(),
  bytes_step: z.number().int().optional(),
  max_images: z.number().int().optional(),
  transformation: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "create_derived": "createDerived",
    "max_width": "maxWidth",
    "min_width": "minWidth",
    "bytes_step": "bytesStep",
    "max_images": "maxImages",
  });
});

/** @internal */
export type ResponsiveBreakpoint$Outbound = {
  create_derived?: boolean | undefined;
  max_width?: number | undefined;
  min_width?: number | undefined;
  bytes_step?: number | undefined;
  max_images?: number | undefined;
  transformation?: string | undefined;
};

/** @internal */
export const ResponsiveBreakpoint$outboundSchema: z.ZodType<
  ResponsiveBreakpoint$Outbound,
  z.ZodTypeDef,
  ResponsiveBreakpoint
> = z.object({
  createDerived: z.boolean().optional(),
  maxWidth: z.number().int().optional(),
  minWidth: z.number().int().optional(),
  bytesStep: z.number().int().optional(),
  maxImages: z.number().int().optional(),
  transformation: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    createDerived: "create_derived",
    maxWidth: "max_width",
    minWidth: "min_width",
    bytesStep: "bytes_step",
    maxImages: "max_images",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponsiveBreakpoint$ {
  /** @deprecated use `ResponsiveBreakpoint$inboundSchema` instead. */
  export const inboundSchema = ResponsiveBreakpoint$inboundSchema;
  /** @deprecated use `ResponsiveBreakpoint$outboundSchema` instead. */
  export const outboundSchema = ResponsiveBreakpoint$outboundSchema;
  /** @deprecated use `ResponsiveBreakpoint$Outbound` instead. */
  export type Outbound = ResponsiveBreakpoint$Outbound;
}

export function responsiveBreakpointToJSON(
  responsiveBreakpoint: ResponsiveBreakpoint,
): string {
  return JSON.stringify(
    ResponsiveBreakpoint$outboundSchema.parse(responsiveBreakpoint),
  );
}

export function responsiveBreakpointFromJSON(
  jsonString: string,
): SafeParseResult<ResponsiveBreakpoint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponsiveBreakpoint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponsiveBreakpoint' from JSON`,
  );
}

/** @internal */
export const ExplicitAssetType$inboundSchema: z.ZodNativeEnum<
  typeof ExplicitAssetType
> = z.nativeEnum(ExplicitAssetType);

/** @internal */
export const ExplicitAssetType$outboundSchema: z.ZodNativeEnum<
  typeof ExplicitAssetType
> = ExplicitAssetType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExplicitAssetType$ {
  /** @deprecated use `ExplicitAssetType$inboundSchema` instead. */
  export const inboundSchema = ExplicitAssetType$inboundSchema;
  /** @deprecated use `ExplicitAssetType$outboundSchema` instead. */
  export const outboundSchema = ExplicitAssetType$outboundSchema;
}

/** @internal */
export const QualityOverride$inboundSchema: z.ZodType<
  QualityOverride,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number().int()]);

/** @internal */
export type QualityOverride$Outbound = string | number;

/** @internal */
export const QualityOverride$outboundSchema: z.ZodType<
  QualityOverride$Outbound,
  z.ZodTypeDef,
  QualityOverride
> = z.union([z.string(), z.number().int()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QualityOverride$ {
  /** @deprecated use `QualityOverride$inboundSchema` instead. */
  export const inboundSchema = QualityOverride$inboundSchema;
  /** @deprecated use `QualityOverride$outboundSchema` instead. */
  export const outboundSchema = QualityOverride$outboundSchema;
  /** @deprecated use `QualityOverride$Outbound` instead. */
  export type Outbound = QualityOverride$Outbound;
}

export function qualityOverrideToJSON(
  qualityOverride: QualityOverride,
): string {
  return JSON.stringify(QualityOverride$outboundSchema.parse(qualityOverride));
}

export function qualityOverrideFromJSON(
  jsonString: string,
): SafeParseResult<QualityOverride, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QualityOverride$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QualityOverride' from JSON`,
  );
}

/** @internal */
export const ExplicitAssetRequestBody$inboundSchema: z.ZodType<
  ExplicitAssetRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  signature: z.string().optional(),
  timestamp: z.number().int().optional(),
  api_key: z.string().optional(),
  accessibility_analysis: z.boolean().optional(),
  asset_folder: z.string().optional(),
  async: z.boolean().optional(),
  auto_chaptering: z.boolean().optional(),
  auto_transcription: z.boolean().optional(),
  cinemagraph_analysis: z.boolean().optional(),
  colors: z.boolean().default(false),
  context: z.string().optional(),
  custom_coordinates: z.string().optional(),
  display_name: z.string().optional(),
  eager: z.string().optional(),
  eager_async: z.boolean().optional(),
  eager_notification_url: z.string().optional(),
  face_coordinates: z.string().optional(),
  faces: z.boolean().optional(),
  headers: z.string().optional(),
  invalidate: z.boolean().optional(),
  media_metadata: z.boolean().optional(),
  metadata: z.string().optional(),
  moderation: ExplicitAssetModeration$inboundSchema.optional(),
  notification_url: z.string().optional(),
  phash: z.boolean().optional(),
  quality_analysis: z.boolean().optional(),
  regions: z.string().optional(),
  responsive_breakpoints: z.array(
    z.lazy(() => ResponsiveBreakpoint$inboundSchema),
  ).optional(),
  tags: z.string().optional(),
  callback: z.string().optional(),
  public_id: z.string(),
  type: ExplicitAssetType$inboundSchema.optional(),
  overwrite: z.boolean().optional(),
  quality_override: z.union([z.string(), z.number().int()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "api_key": "apiKey",
    "accessibility_analysis": "accessibilityAnalysis",
    "asset_folder": "assetFolder",
    "auto_chaptering": "autoChaptering",
    "auto_transcription": "autoTranscription",
    "cinemagraph_analysis": "cinemagraphAnalysis",
    "custom_coordinates": "customCoordinates",
    "display_name": "displayName",
    "eager_async": "eagerAsync",
    "eager_notification_url": "eagerNotificationUrl",
    "face_coordinates": "faceCoordinates",
    "media_metadata": "mediaMetadata",
    "notification_url": "notificationUrl",
    "quality_analysis": "qualityAnalysis",
    "responsive_breakpoints": "responsiveBreakpoints",
    "public_id": "publicId",
    "quality_override": "qualityOverride",
  });
});

/** @internal */
export type ExplicitAssetRequestBody$Outbound = {
  signature?: string | undefined;
  timestamp?: number | undefined;
  api_key?: string | undefined;
  accessibility_analysis?: boolean | undefined;
  asset_folder?: string | undefined;
  async?: boolean | undefined;
  auto_chaptering?: boolean | undefined;
  auto_transcription?: boolean | undefined;
  cinemagraph_analysis?: boolean | undefined;
  colors: boolean;
  context?: string | undefined;
  custom_coordinates?: string | undefined;
  display_name?: string | undefined;
  eager?: string | undefined;
  eager_async?: boolean | undefined;
  eager_notification_url?: string | undefined;
  face_coordinates?: string | undefined;
  faces?: boolean | undefined;
  headers?: string | undefined;
  invalidate?: boolean | undefined;
  media_metadata?: boolean | undefined;
  metadata?: string | undefined;
  moderation?: string | undefined;
  notification_url?: string | undefined;
  phash?: boolean | undefined;
  quality_analysis?: boolean | undefined;
  regions?: string | undefined;
  responsive_breakpoints?: Array<ResponsiveBreakpoint$Outbound> | undefined;
  tags?: string | undefined;
  callback?: string | undefined;
  public_id: string;
  type?: string | undefined;
  overwrite?: boolean | undefined;
  quality_override?: string | number | undefined;
};

/** @internal */
export const ExplicitAssetRequestBody$outboundSchema: z.ZodType<
  ExplicitAssetRequestBody$Outbound,
  z.ZodTypeDef,
  ExplicitAssetRequestBody
> = z.object({
  signature: z.string().optional(),
  timestamp: z.number().int().optional(),
  apiKey: z.string().optional(),
  accessibilityAnalysis: z.boolean().optional(),
  assetFolder: z.string().optional(),
  async: z.boolean().optional(),
  autoChaptering: z.boolean().optional(),
  autoTranscription: z.boolean().optional(),
  cinemagraphAnalysis: z.boolean().optional(),
  colors: z.boolean().default(false),
  context: z.string().optional(),
  customCoordinates: z.string().optional(),
  displayName: z.string().optional(),
  eager: z.string().optional(),
  eagerAsync: z.boolean().optional(),
  eagerNotificationUrl: z.string().optional(),
  faceCoordinates: z.string().optional(),
  faces: z.boolean().optional(),
  headers: z.string().optional(),
  invalidate: z.boolean().optional(),
  mediaMetadata: z.boolean().optional(),
  metadata: z.string().optional(),
  moderation: ExplicitAssetModeration$outboundSchema.optional(),
  notificationUrl: z.string().optional(),
  phash: z.boolean().optional(),
  qualityAnalysis: z.boolean().optional(),
  regions: z.string().optional(),
  responsiveBreakpoints: z.array(
    z.lazy(() => ResponsiveBreakpoint$outboundSchema),
  ).optional(),
  tags: z.string().optional(),
  callback: z.string().optional(),
  publicId: z.string(),
  type: ExplicitAssetType$outboundSchema.optional(),
  overwrite: z.boolean().optional(),
  qualityOverride: z.union([z.string(), z.number().int()]).optional(),
}).transform((v) => {
  return remap$(v, {
    apiKey: "api_key",
    accessibilityAnalysis: "accessibility_analysis",
    assetFolder: "asset_folder",
    autoChaptering: "auto_chaptering",
    autoTranscription: "auto_transcription",
    cinemagraphAnalysis: "cinemagraph_analysis",
    customCoordinates: "custom_coordinates",
    displayName: "display_name",
    eagerAsync: "eager_async",
    eagerNotificationUrl: "eager_notification_url",
    faceCoordinates: "face_coordinates",
    mediaMetadata: "media_metadata",
    notificationUrl: "notification_url",
    qualityAnalysis: "quality_analysis",
    responsiveBreakpoints: "responsive_breakpoints",
    publicId: "public_id",
    qualityOverride: "quality_override",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExplicitAssetRequestBody$ {
  /** @deprecated use `ExplicitAssetRequestBody$inboundSchema` instead. */
  export const inboundSchema = ExplicitAssetRequestBody$inboundSchema;
  /** @deprecated use `ExplicitAssetRequestBody$outboundSchema` instead. */
  export const outboundSchema = ExplicitAssetRequestBody$outboundSchema;
  /** @deprecated use `ExplicitAssetRequestBody$Outbound` instead. */
  export type Outbound = ExplicitAssetRequestBody$Outbound;
}

export function explicitAssetRequestBodyToJSON(
  explicitAssetRequestBody: ExplicitAssetRequestBody,
): string {
  return JSON.stringify(
    ExplicitAssetRequestBody$outboundSchema.parse(explicitAssetRequestBody),
  );
}

export function explicitAssetRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<ExplicitAssetRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExplicitAssetRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExplicitAssetRequestBody' from JSON`,
  );
}

/** @internal */
export const ExplicitAssetRequest$inboundSchema: z.ZodType<
  ExplicitAssetRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource_type: ExplicitAssetResourceType$inboundSchema,
  RequestBody: z.lazy(() => ExplicitAssetRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "resource_type": "resourceType",
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type ExplicitAssetRequest$Outbound = {
  resource_type: string;
  RequestBody: ExplicitAssetRequestBody$Outbound;
};

/** @internal */
export const ExplicitAssetRequest$outboundSchema: z.ZodType<
  ExplicitAssetRequest$Outbound,
  z.ZodTypeDef,
  ExplicitAssetRequest
> = z.object({
  resourceType: ExplicitAssetResourceType$outboundSchema,
  requestBody: z.lazy(() => ExplicitAssetRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    resourceType: "resource_type",
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExplicitAssetRequest$ {
  /** @deprecated use `ExplicitAssetRequest$inboundSchema` instead. */
  export const inboundSchema = ExplicitAssetRequest$inboundSchema;
  /** @deprecated use `ExplicitAssetRequest$outboundSchema` instead. */
  export const outboundSchema = ExplicitAssetRequest$outboundSchema;
  /** @deprecated use `ExplicitAssetRequest$Outbound` instead. */
  export type Outbound = ExplicitAssetRequest$Outbound;
}

export function explicitAssetRequestToJSON(
  explicitAssetRequest: ExplicitAssetRequest,
): string {
  return JSON.stringify(
    ExplicitAssetRequest$outboundSchema.parse(explicitAssetRequest),
  );
}

export function explicitAssetRequestFromJSON(
  jsonString: string,
): SafeParseResult<ExplicitAssetRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExplicitAssetRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExplicitAssetRequest' from JSON`,
  );
}
