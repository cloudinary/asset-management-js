/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type DestroyRequest = {
  /**
   * The API key to use for the request. This is automatically computed by the Cloudinary's SDKs.
   */
  apiKey?: string | undefined;
  /**
   * The timestamp to use for the request in unix time. This is automatically computed by the Cloudinary's SDKs.
   */
  timestamp?: number | undefined;
  /**
   * (Required for signed REST API calls) Used to authenticate the request and based on the parameters you use in the request. When using the Cloudinary SDKs for signed requests, the signature is automatically generated and added to the request. If you manually generate your own signed POST request, you need to manually generate the signature parameter and add it to the request together with the api_key and timestamp parameters.
   *
   * @remarks
   */
  signature?: string | undefined;
  /**
   * The ID of the asset to delete.
   */
  assetId: string;
  /**
   * Whether to invalidate CDN cache. Default is false.
   */
  invalidate?: boolean | undefined;
  /**
   * URL to receive completion notification.
   */
  notificationUrl?: string | undefined;
  /**
   * URL for redirect after operation completion.
   */
  callback?: string | undefined;
};

/** @internal */
export const DestroyRequest$inboundSchema: z.ZodType<
  DestroyRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  api_key: z.string().optional(),
  timestamp: z.number().int().optional(),
  signature: z.string().optional(),
  asset_id: z.string(),
  invalidate: z.boolean().optional(),
  notification_url: z.string().optional(),
  callback: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "api_key": "apiKey",
    "asset_id": "assetId",
    "notification_url": "notificationUrl",
  });
});

/** @internal */
export type DestroyRequest$Outbound = {
  api_key?: string | undefined;
  timestamp?: number | undefined;
  signature?: string | undefined;
  asset_id: string;
  invalidate?: boolean | undefined;
  notification_url?: string | undefined;
  callback?: string | undefined;
};

/** @internal */
export const DestroyRequest$outboundSchema: z.ZodType<
  DestroyRequest$Outbound,
  z.ZodTypeDef,
  DestroyRequest
> = z.object({
  apiKey: z.string().optional(),
  timestamp: z.number().int().optional(),
  signature: z.string().optional(),
  assetId: z.string(),
  invalidate: z.boolean().optional(),
  notificationUrl: z.string().optional(),
  callback: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    apiKey: "api_key",
    assetId: "asset_id",
    notificationUrl: "notification_url",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DestroyRequest$ {
  /** @deprecated use `DestroyRequest$inboundSchema` instead. */
  export const inboundSchema = DestroyRequest$inboundSchema;
  /** @deprecated use `DestroyRequest$outboundSchema` instead. */
  export const outboundSchema = DestroyRequest$outboundSchema;
  /** @deprecated use `DestroyRequest$Outbound` instead. */
  export type Outbound = DestroyRequest$Outbound;
}

export function destroyRequestToJSON(destroyRequest: DestroyRequest): string {
  return JSON.stringify(DestroyRequest$outboundSchema.parse(destroyRequest));
}

export function destroyRequestFromJSON(
  jsonString: string,
): SafeParseResult<DestroyRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DestroyRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DestroyRequest' from JSON`,
  );
}
