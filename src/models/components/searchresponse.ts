/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The type of resource.
 */
export const SearchResponseResourceType = {
  Image: "image",
  Video: "video",
  Raw: "raw",
} as const;
/**
 * The type of resource.
 */
export type SearchResponseResourceType = ClosedEnum<
  typeof SearchResponseResourceType
>;

/**
 * The delivery type of the asset.
 */
export const SearchResponseType = {
  Upload: "upload",
  Private: "private",
  Authenticated: "authenticated",
  List: "list",
  Fetch: "fetch",
} as const;
/**
 * The delivery type of the asset.
 */
export type SearchResponseType = ClosedEnum<typeof SearchResponseType>;

/**
 * The current status of the asset.
 */
export const SearchResponseStatus = {
  Active: "active",
  Inactive: "inactive",
} as const;
/**
 * The current status of the asset.
 */
export type SearchResponseStatus = ClosedEnum<typeof SearchResponseStatus>;

/**
 * The access mode of the asset.
 */
export const SearchResponseAccessMode = {
  Public: "public",
  Authenticated: "authenticated",
} as const;
/**
 * The access mode of the asset.
 */
export type SearchResponseAccessMode = ClosedEnum<
  typeof SearchResponseAccessMode
>;

/**
 * The access control settings for the asset.
 */
export type SearchResponseAccessControl = {};

/**
 * Information about who created the asset.
 */
export type CreatedBy = {
  /**
   * The access key of the user who created the asset.
   */
  accessKey?: string | undefined;
};

/**
 * Information about who uploaded the asset.
 */
export type UploadedBy = {
  /**
   * The access key of the user who uploaded the asset.
   */
  accessKey?: string | undefined;
};

/**
 * Custom context metadata associated with the asset.
 */
export type SearchResponseContext = {};

/**
 * Technical metadata extracted from the image.
 */
export type SearchResponseImageMetadata = {};

/**
 * Results of image analysis.
 */
export type ImageAnalysis = {};

/**
 * Structured metadata associated with the asset.
 */
export type Metadata = {};

/**
 * Results of quality analysis.
 */
export type QualityAnalysis = {};

/**
 * Results of accessibility analysis.
 */
export type AccessibilityAnalysis = {};

/**
 * Resource fields that can be returned. All fields are optional and can be filtered using the fields parameter.
 */
export type Resource = {
  /**
   * The unique identifier of the asset.
   */
  assetId?: string | undefined;
  /**
   * The public identifier that is used to build the URL.
   */
  publicId?: string | undefined;
  /**
   * The folder where the asset is stored.
   */
  assetFolder?: string | undefined;
  /**
   * The original filename of the asset.
   */
  filename?: string | undefined;
  /**
   * The display name of the asset.
   */
  displayName?: string | undefined;
  /**
   * The format of the asset.
   */
  format?: string | undefined;
  /**
   * The version number of the asset.
   */
  version?: number | undefined;
  /**
   * The type of resource.
   */
  resourceType?: SearchResponseResourceType | undefined;
  /**
   * The delivery type of the asset.
   */
  type?: SearchResponseType | undefined;
  /**
   * The timestamp when the asset was created.
   */
  createdAt?: Date | undefined;
  /**
   * The timestamp when the asset was uploaded.
   */
  uploadedAt?: Date | undefined;
  /**
   * The size of the asset in bytes.
   */
  bytes?: number | undefined;
  /**
   * The size of the backup asset in bytes.
   */
  backupBytes?: number | undefined;
  /**
   * The width of the asset in pixels.
   */
  width?: number | undefined;
  /**
   * The height of the asset in pixels.
   */
  height?: number | undefined;
  /**
   * The aspect ratio of the asset (width/height).
   */
  aspectRatio?: number | undefined;
  /**
   * The total number of pixels in the asset.
   */
  pixels?: number | undefined;
  /**
   * The HTTP URL for accessing the asset.
   */
  url?: string | undefined;
  /**
   * The HTTPS URL for accessing the asset.
   */
  secureUrl?: string | undefined;
  /**
   * The current status of the asset.
   */
  status?: SearchResponseStatus | undefined;
  /**
   * The access mode of the asset.
   */
  accessMode?: SearchResponseAccessMode | undefined;
  /**
   * The access control settings for the asset.
   */
  accessControl?: SearchResponseAccessControl | null | undefined;
  /**
   * The ETag of the asset.
   */
  etag?: string | undefined;
  /**
   * Information about who created the asset.
   */
  createdBy?: CreatedBy | null | undefined;
  /**
   * Information about who uploaded the asset.
   */
  uploadedBy?: UploadedBy | null | undefined;
  /**
   * Custom context metadata associated with the asset.
   */
  context?: SearchResponseContext | undefined;
  /**
   * Tags associated with the asset.
   */
  tags?: Array<string> | undefined;
  /**
   * Technical metadata extracted from the image.
   */
  imageMetadata?: SearchResponseImageMetadata | null | undefined;
  /**
   * Results of image analysis.
   */
  imageAnalysis?: ImageAnalysis | null | undefined;
  /**
   * Structured metadata associated with the asset.
   */
  metadata?: Metadata | null | undefined;
  /**
   * Results of quality analysis.
   */
  qualityAnalysis?: QualityAnalysis | null | undefined;
  /**
   * Results of accessibility analysis.
   */
  accessibilityAnalysis?: AccessibilityAnalysis | null | undefined;
};

export type Value = {
  /**
   * The value being aggregated
   */
  value?: string | undefined;
  /**
   * The count of resources with this value
   */
  count?: number | undefined;
};

export type SearchResponseRange = {
  /**
   * Start of the range (inclusive)
   */
  from?: number | undefined;
  /**
   * End of the range (exclusive)
   */
  to?: number | undefined;
  /**
   * The count of resources within this range
   */
  count?: number | undefined;
};

/**
 * Aggregation results when the aggregate parameter is used in the request. Only included when aggregations are requested.
 */
export type Aggregations = {
  /**
   * Array of aggregation values when using simple aggregation (e.g., by format, resource_type, etc.)
   */
  values?: Array<Value> | undefined;
  /**
   * Array of range-based aggregation results when using range aggregation (e.g., bytes, width, height, etc.)
   */
  ranges?: Array<SearchResponseRange> | undefined;
};

/**
 * The response object returned by search operations.
 */
export type SearchResponse = {
  /**
   * The total number of resources matching the search criteria.
   */
  totalCount?: number | undefined;
  /**
   * The time taken to execute the search query in milliseconds.
   */
  time?: number | undefined;
  /**
   * The list of resources matching the search criteria. Can be empty if no results found.
   */
  resources?: Array<Resource> | undefined;
  /**
   * A cursor for pagination. Only included when there are more results available.
   */
  nextCursor?: string | null | undefined;
  /**
   * Aggregation results when the aggregate parameter is used in the request. Only included when aggregations are requested.
   */
  aggregations?: Aggregations | undefined;
};

/** @internal */
export const SearchResponseResourceType$inboundSchema: z.ZodNativeEnum<
  typeof SearchResponseResourceType
> = z.nativeEnum(SearchResponseResourceType);

/** @internal */
export const SearchResponseResourceType$outboundSchema: z.ZodNativeEnum<
  typeof SearchResponseResourceType
> = SearchResponseResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchResponseResourceType$ {
  /** @deprecated use `SearchResponseResourceType$inboundSchema` instead. */
  export const inboundSchema = SearchResponseResourceType$inboundSchema;
  /** @deprecated use `SearchResponseResourceType$outboundSchema` instead. */
  export const outboundSchema = SearchResponseResourceType$outboundSchema;
}

/** @internal */
export const SearchResponseType$inboundSchema: z.ZodNativeEnum<
  typeof SearchResponseType
> = z.nativeEnum(SearchResponseType);

/** @internal */
export const SearchResponseType$outboundSchema: z.ZodNativeEnum<
  typeof SearchResponseType
> = SearchResponseType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchResponseType$ {
  /** @deprecated use `SearchResponseType$inboundSchema` instead. */
  export const inboundSchema = SearchResponseType$inboundSchema;
  /** @deprecated use `SearchResponseType$outboundSchema` instead. */
  export const outboundSchema = SearchResponseType$outboundSchema;
}

/** @internal */
export const SearchResponseStatus$inboundSchema: z.ZodNativeEnum<
  typeof SearchResponseStatus
> = z.nativeEnum(SearchResponseStatus);

/** @internal */
export const SearchResponseStatus$outboundSchema: z.ZodNativeEnum<
  typeof SearchResponseStatus
> = SearchResponseStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchResponseStatus$ {
  /** @deprecated use `SearchResponseStatus$inboundSchema` instead. */
  export const inboundSchema = SearchResponseStatus$inboundSchema;
  /** @deprecated use `SearchResponseStatus$outboundSchema` instead. */
  export const outboundSchema = SearchResponseStatus$outboundSchema;
}

/** @internal */
export const SearchResponseAccessMode$inboundSchema: z.ZodNativeEnum<
  typeof SearchResponseAccessMode
> = z.nativeEnum(SearchResponseAccessMode);

/** @internal */
export const SearchResponseAccessMode$outboundSchema: z.ZodNativeEnum<
  typeof SearchResponseAccessMode
> = SearchResponseAccessMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchResponseAccessMode$ {
  /** @deprecated use `SearchResponseAccessMode$inboundSchema` instead. */
  export const inboundSchema = SearchResponseAccessMode$inboundSchema;
  /** @deprecated use `SearchResponseAccessMode$outboundSchema` instead. */
  export const outboundSchema = SearchResponseAccessMode$outboundSchema;
}

/** @internal */
export const SearchResponseAccessControl$inboundSchema: z.ZodType<
  SearchResponseAccessControl,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type SearchResponseAccessControl$Outbound = {};

/** @internal */
export const SearchResponseAccessControl$outboundSchema: z.ZodType<
  SearchResponseAccessControl$Outbound,
  z.ZodTypeDef,
  SearchResponseAccessControl
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchResponseAccessControl$ {
  /** @deprecated use `SearchResponseAccessControl$inboundSchema` instead. */
  export const inboundSchema = SearchResponseAccessControl$inboundSchema;
  /** @deprecated use `SearchResponseAccessControl$outboundSchema` instead. */
  export const outboundSchema = SearchResponseAccessControl$outboundSchema;
  /** @deprecated use `SearchResponseAccessControl$Outbound` instead. */
  export type Outbound = SearchResponseAccessControl$Outbound;
}

export function searchResponseAccessControlToJSON(
  searchResponseAccessControl: SearchResponseAccessControl,
): string {
  return JSON.stringify(
    SearchResponseAccessControl$outboundSchema.parse(
      searchResponseAccessControl,
    ),
  );
}

export function searchResponseAccessControlFromJSON(
  jsonString: string,
): SafeParseResult<SearchResponseAccessControl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchResponseAccessControl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchResponseAccessControl' from JSON`,
  );
}

/** @internal */
export const CreatedBy$inboundSchema: z.ZodType<
  CreatedBy,
  z.ZodTypeDef,
  unknown
> = z.object({
  access_key: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "access_key": "accessKey",
  });
});

/** @internal */
export type CreatedBy$Outbound = {
  access_key?: string | undefined;
};

/** @internal */
export const CreatedBy$outboundSchema: z.ZodType<
  CreatedBy$Outbound,
  z.ZodTypeDef,
  CreatedBy
> = z.object({
  accessKey: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    accessKey: "access_key",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatedBy$ {
  /** @deprecated use `CreatedBy$inboundSchema` instead. */
  export const inboundSchema = CreatedBy$inboundSchema;
  /** @deprecated use `CreatedBy$outboundSchema` instead. */
  export const outboundSchema = CreatedBy$outboundSchema;
  /** @deprecated use `CreatedBy$Outbound` instead. */
  export type Outbound = CreatedBy$Outbound;
}

export function createdByToJSON(createdBy: CreatedBy): string {
  return JSON.stringify(CreatedBy$outboundSchema.parse(createdBy));
}

export function createdByFromJSON(
  jsonString: string,
): SafeParseResult<CreatedBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatedBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatedBy' from JSON`,
  );
}

/** @internal */
export const UploadedBy$inboundSchema: z.ZodType<
  UploadedBy,
  z.ZodTypeDef,
  unknown
> = z.object({
  access_key: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "access_key": "accessKey",
  });
});

/** @internal */
export type UploadedBy$Outbound = {
  access_key?: string | undefined;
};

/** @internal */
export const UploadedBy$outboundSchema: z.ZodType<
  UploadedBy$Outbound,
  z.ZodTypeDef,
  UploadedBy
> = z.object({
  accessKey: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    accessKey: "access_key",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UploadedBy$ {
  /** @deprecated use `UploadedBy$inboundSchema` instead. */
  export const inboundSchema = UploadedBy$inboundSchema;
  /** @deprecated use `UploadedBy$outboundSchema` instead. */
  export const outboundSchema = UploadedBy$outboundSchema;
  /** @deprecated use `UploadedBy$Outbound` instead. */
  export type Outbound = UploadedBy$Outbound;
}

export function uploadedByToJSON(uploadedBy: UploadedBy): string {
  return JSON.stringify(UploadedBy$outboundSchema.parse(uploadedBy));
}

export function uploadedByFromJSON(
  jsonString: string,
): SafeParseResult<UploadedBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UploadedBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UploadedBy' from JSON`,
  );
}

/** @internal */
export const SearchResponseContext$inboundSchema: z.ZodType<
  SearchResponseContext,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type SearchResponseContext$Outbound = {};

/** @internal */
export const SearchResponseContext$outboundSchema: z.ZodType<
  SearchResponseContext$Outbound,
  z.ZodTypeDef,
  SearchResponseContext
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchResponseContext$ {
  /** @deprecated use `SearchResponseContext$inboundSchema` instead. */
  export const inboundSchema = SearchResponseContext$inboundSchema;
  /** @deprecated use `SearchResponseContext$outboundSchema` instead. */
  export const outboundSchema = SearchResponseContext$outboundSchema;
  /** @deprecated use `SearchResponseContext$Outbound` instead. */
  export type Outbound = SearchResponseContext$Outbound;
}

export function searchResponseContextToJSON(
  searchResponseContext: SearchResponseContext,
): string {
  return JSON.stringify(
    SearchResponseContext$outboundSchema.parse(searchResponseContext),
  );
}

export function searchResponseContextFromJSON(
  jsonString: string,
): SafeParseResult<SearchResponseContext, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchResponseContext$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchResponseContext' from JSON`,
  );
}

/** @internal */
export const SearchResponseImageMetadata$inboundSchema: z.ZodType<
  SearchResponseImageMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type SearchResponseImageMetadata$Outbound = {};

/** @internal */
export const SearchResponseImageMetadata$outboundSchema: z.ZodType<
  SearchResponseImageMetadata$Outbound,
  z.ZodTypeDef,
  SearchResponseImageMetadata
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchResponseImageMetadata$ {
  /** @deprecated use `SearchResponseImageMetadata$inboundSchema` instead. */
  export const inboundSchema = SearchResponseImageMetadata$inboundSchema;
  /** @deprecated use `SearchResponseImageMetadata$outboundSchema` instead. */
  export const outboundSchema = SearchResponseImageMetadata$outboundSchema;
  /** @deprecated use `SearchResponseImageMetadata$Outbound` instead. */
  export type Outbound = SearchResponseImageMetadata$Outbound;
}

export function searchResponseImageMetadataToJSON(
  searchResponseImageMetadata: SearchResponseImageMetadata,
): string {
  return JSON.stringify(
    SearchResponseImageMetadata$outboundSchema.parse(
      searchResponseImageMetadata,
    ),
  );
}

export function searchResponseImageMetadataFromJSON(
  jsonString: string,
): SafeParseResult<SearchResponseImageMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchResponseImageMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchResponseImageMetadata' from JSON`,
  );
}

/** @internal */
export const ImageAnalysis$inboundSchema: z.ZodType<
  ImageAnalysis,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ImageAnalysis$Outbound = {};

/** @internal */
export const ImageAnalysis$outboundSchema: z.ZodType<
  ImageAnalysis$Outbound,
  z.ZodTypeDef,
  ImageAnalysis
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ImageAnalysis$ {
  /** @deprecated use `ImageAnalysis$inboundSchema` instead. */
  export const inboundSchema = ImageAnalysis$inboundSchema;
  /** @deprecated use `ImageAnalysis$outboundSchema` instead. */
  export const outboundSchema = ImageAnalysis$outboundSchema;
  /** @deprecated use `ImageAnalysis$Outbound` instead. */
  export type Outbound = ImageAnalysis$Outbound;
}

export function imageAnalysisToJSON(imageAnalysis: ImageAnalysis): string {
  return JSON.stringify(ImageAnalysis$outboundSchema.parse(imageAnalysis));
}

export function imageAnalysisFromJSON(
  jsonString: string,
): SafeParseResult<ImageAnalysis, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ImageAnalysis$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ImageAnalysis' from JSON`,
  );
}

/** @internal */
export const Metadata$inboundSchema: z.ZodType<
  Metadata,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type Metadata$Outbound = {};

/** @internal */
export const Metadata$outboundSchema: z.ZodType<
  Metadata$Outbound,
  z.ZodTypeDef,
  Metadata
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Metadata$ {
  /** @deprecated use `Metadata$inboundSchema` instead. */
  export const inboundSchema = Metadata$inboundSchema;
  /** @deprecated use `Metadata$outboundSchema` instead. */
  export const outboundSchema = Metadata$outboundSchema;
  /** @deprecated use `Metadata$Outbound` instead. */
  export type Outbound = Metadata$Outbound;
}

export function metadataToJSON(metadata: Metadata): string {
  return JSON.stringify(Metadata$outboundSchema.parse(metadata));
}

export function metadataFromJSON(
  jsonString: string,
): SafeParseResult<Metadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Metadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Metadata' from JSON`,
  );
}

/** @internal */
export const QualityAnalysis$inboundSchema: z.ZodType<
  QualityAnalysis,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type QualityAnalysis$Outbound = {};

/** @internal */
export const QualityAnalysis$outboundSchema: z.ZodType<
  QualityAnalysis$Outbound,
  z.ZodTypeDef,
  QualityAnalysis
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QualityAnalysis$ {
  /** @deprecated use `QualityAnalysis$inboundSchema` instead. */
  export const inboundSchema = QualityAnalysis$inboundSchema;
  /** @deprecated use `QualityAnalysis$outboundSchema` instead. */
  export const outboundSchema = QualityAnalysis$outboundSchema;
  /** @deprecated use `QualityAnalysis$Outbound` instead. */
  export type Outbound = QualityAnalysis$Outbound;
}

export function qualityAnalysisToJSON(
  qualityAnalysis: QualityAnalysis,
): string {
  return JSON.stringify(QualityAnalysis$outboundSchema.parse(qualityAnalysis));
}

export function qualityAnalysisFromJSON(
  jsonString: string,
): SafeParseResult<QualityAnalysis, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QualityAnalysis$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QualityAnalysis' from JSON`,
  );
}

/** @internal */
export const AccessibilityAnalysis$inboundSchema: z.ZodType<
  AccessibilityAnalysis,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type AccessibilityAnalysis$Outbound = {};

/** @internal */
export const AccessibilityAnalysis$outboundSchema: z.ZodType<
  AccessibilityAnalysis$Outbound,
  z.ZodTypeDef,
  AccessibilityAnalysis
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AccessibilityAnalysis$ {
  /** @deprecated use `AccessibilityAnalysis$inboundSchema` instead. */
  export const inboundSchema = AccessibilityAnalysis$inboundSchema;
  /** @deprecated use `AccessibilityAnalysis$outboundSchema` instead. */
  export const outboundSchema = AccessibilityAnalysis$outboundSchema;
  /** @deprecated use `AccessibilityAnalysis$Outbound` instead. */
  export type Outbound = AccessibilityAnalysis$Outbound;
}

export function accessibilityAnalysisToJSON(
  accessibilityAnalysis: AccessibilityAnalysis,
): string {
  return JSON.stringify(
    AccessibilityAnalysis$outboundSchema.parse(accessibilityAnalysis),
  );
}

export function accessibilityAnalysisFromJSON(
  jsonString: string,
): SafeParseResult<AccessibilityAnalysis, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AccessibilityAnalysis$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AccessibilityAnalysis' from JSON`,
  );
}

/** @internal */
export const Resource$inboundSchema: z.ZodType<
  Resource,
  z.ZodTypeDef,
  unknown
> = z.object({
  asset_id: z.string().optional(),
  public_id: z.string().optional(),
  asset_folder: z.string().optional(),
  filename: z.string().optional(),
  display_name: z.string().optional(),
  format: z.string().optional(),
  version: z.number().int().optional(),
  resource_type: SearchResponseResourceType$inboundSchema.optional(),
  type: SearchResponseType$inboundSchema.optional(),
  created_at: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  uploaded_at: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  bytes: z.number().int().optional(),
  backup_bytes: z.number().int().optional(),
  width: z.number().int().optional(),
  height: z.number().int().optional(),
  aspect_ratio: z.number().optional(),
  pixels: z.number().int().optional(),
  url: z.string().optional(),
  secure_url: z.string().optional(),
  status: SearchResponseStatus$inboundSchema.optional(),
  access_mode: SearchResponseAccessMode$inboundSchema.optional(),
  access_control: z.nullable(
    z.lazy(() => SearchResponseAccessControl$inboundSchema),
  ).optional(),
  etag: z.string().optional(),
  created_by: z.nullable(z.lazy(() => CreatedBy$inboundSchema)).optional(),
  uploaded_by: z.nullable(z.lazy(() => UploadedBy$inboundSchema)).optional(),
  context: z.lazy(() => SearchResponseContext$inboundSchema).optional(),
  tags: z.array(z.string()).optional(),
  image_metadata: z.nullable(
    z.lazy(() => SearchResponseImageMetadata$inboundSchema),
  ).optional(),
  image_analysis: z.nullable(z.lazy(() => ImageAnalysis$inboundSchema))
    .optional(),
  metadata: z.nullable(z.lazy(() => Metadata$inboundSchema)).optional(),
  quality_analysis: z.nullable(z.lazy(() => QualityAnalysis$inboundSchema))
    .optional(),
  accessibility_analysis: z.nullable(
    z.lazy(() => AccessibilityAnalysis$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "asset_id": "assetId",
    "public_id": "publicId",
    "asset_folder": "assetFolder",
    "display_name": "displayName",
    "resource_type": "resourceType",
    "created_at": "createdAt",
    "uploaded_at": "uploadedAt",
    "backup_bytes": "backupBytes",
    "aspect_ratio": "aspectRatio",
    "secure_url": "secureUrl",
    "access_mode": "accessMode",
    "access_control": "accessControl",
    "created_by": "createdBy",
    "uploaded_by": "uploadedBy",
    "image_metadata": "imageMetadata",
    "image_analysis": "imageAnalysis",
    "quality_analysis": "qualityAnalysis",
    "accessibility_analysis": "accessibilityAnalysis",
  });
});

/** @internal */
export type Resource$Outbound = {
  asset_id?: string | undefined;
  public_id?: string | undefined;
  asset_folder?: string | undefined;
  filename?: string | undefined;
  display_name?: string | undefined;
  format?: string | undefined;
  version?: number | undefined;
  resource_type?: string | undefined;
  type?: string | undefined;
  created_at?: string | undefined;
  uploaded_at?: string | undefined;
  bytes?: number | undefined;
  backup_bytes?: number | undefined;
  width?: number | undefined;
  height?: number | undefined;
  aspect_ratio?: number | undefined;
  pixels?: number | undefined;
  url?: string | undefined;
  secure_url?: string | undefined;
  status?: string | undefined;
  access_mode?: string | undefined;
  access_control?: SearchResponseAccessControl$Outbound | null | undefined;
  etag?: string | undefined;
  created_by?: CreatedBy$Outbound | null | undefined;
  uploaded_by?: UploadedBy$Outbound | null | undefined;
  context?: SearchResponseContext$Outbound | undefined;
  tags?: Array<string> | undefined;
  image_metadata?: SearchResponseImageMetadata$Outbound | null | undefined;
  image_analysis?: ImageAnalysis$Outbound | null | undefined;
  metadata?: Metadata$Outbound | null | undefined;
  quality_analysis?: QualityAnalysis$Outbound | null | undefined;
  accessibility_analysis?: AccessibilityAnalysis$Outbound | null | undefined;
};

/** @internal */
export const Resource$outboundSchema: z.ZodType<
  Resource$Outbound,
  z.ZodTypeDef,
  Resource
> = z.object({
  assetId: z.string().optional(),
  publicId: z.string().optional(),
  assetFolder: z.string().optional(),
  filename: z.string().optional(),
  displayName: z.string().optional(),
  format: z.string().optional(),
  version: z.number().int().optional(),
  resourceType: SearchResponseResourceType$outboundSchema.optional(),
  type: SearchResponseType$outboundSchema.optional(),
  createdAt: z.date().transform(v => v.toISOString()).optional(),
  uploadedAt: z.date().transform(v => v.toISOString()).optional(),
  bytes: z.number().int().optional(),
  backupBytes: z.number().int().optional(),
  width: z.number().int().optional(),
  height: z.number().int().optional(),
  aspectRatio: z.number().optional(),
  pixels: z.number().int().optional(),
  url: z.string().optional(),
  secureUrl: z.string().optional(),
  status: SearchResponseStatus$outboundSchema.optional(),
  accessMode: SearchResponseAccessMode$outboundSchema.optional(),
  accessControl: z.nullable(
    z.lazy(() => SearchResponseAccessControl$outboundSchema),
  ).optional(),
  etag: z.string().optional(),
  createdBy: z.nullable(z.lazy(() => CreatedBy$outboundSchema)).optional(),
  uploadedBy: z.nullable(z.lazy(() => UploadedBy$outboundSchema)).optional(),
  context: z.lazy(() => SearchResponseContext$outboundSchema).optional(),
  tags: z.array(z.string()).optional(),
  imageMetadata: z.nullable(
    z.lazy(() => SearchResponseImageMetadata$outboundSchema),
  ).optional(),
  imageAnalysis: z.nullable(z.lazy(() => ImageAnalysis$outboundSchema))
    .optional(),
  metadata: z.nullable(z.lazy(() => Metadata$outboundSchema)).optional(),
  qualityAnalysis: z.nullable(z.lazy(() => QualityAnalysis$outboundSchema))
    .optional(),
  accessibilityAnalysis: z.nullable(
    z.lazy(() => AccessibilityAnalysis$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    assetId: "asset_id",
    publicId: "public_id",
    assetFolder: "asset_folder",
    displayName: "display_name",
    resourceType: "resource_type",
    createdAt: "created_at",
    uploadedAt: "uploaded_at",
    backupBytes: "backup_bytes",
    aspectRatio: "aspect_ratio",
    secureUrl: "secure_url",
    accessMode: "access_mode",
    accessControl: "access_control",
    createdBy: "created_by",
    uploadedBy: "uploaded_by",
    imageMetadata: "image_metadata",
    imageAnalysis: "image_analysis",
    qualityAnalysis: "quality_analysis",
    accessibilityAnalysis: "accessibility_analysis",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Resource$ {
  /** @deprecated use `Resource$inboundSchema` instead. */
  export const inboundSchema = Resource$inboundSchema;
  /** @deprecated use `Resource$outboundSchema` instead. */
  export const outboundSchema = Resource$outboundSchema;
  /** @deprecated use `Resource$Outbound` instead. */
  export type Outbound = Resource$Outbound;
}

export function resourceToJSON(resource: Resource): string {
  return JSON.stringify(Resource$outboundSchema.parse(resource));
}

export function resourceFromJSON(
  jsonString: string,
): SafeParseResult<Resource, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Resource$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Resource' from JSON`,
  );
}

/** @internal */
export const Value$inboundSchema: z.ZodType<Value, z.ZodTypeDef, unknown> = z
  .object({
    value: z.string().optional(),
    count: z.number().int().optional(),
  });

/** @internal */
export type Value$Outbound = {
  value?: string | undefined;
  count?: number | undefined;
};

/** @internal */
export const Value$outboundSchema: z.ZodType<
  Value$Outbound,
  z.ZodTypeDef,
  Value
> = z.object({
  value: z.string().optional(),
  count: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Value$ {
  /** @deprecated use `Value$inboundSchema` instead. */
  export const inboundSchema = Value$inboundSchema;
  /** @deprecated use `Value$outboundSchema` instead. */
  export const outboundSchema = Value$outboundSchema;
  /** @deprecated use `Value$Outbound` instead. */
  export type Outbound = Value$Outbound;
}

export function valueToJSON(value: Value): string {
  return JSON.stringify(Value$outboundSchema.parse(value));
}

export function valueFromJSON(
  jsonString: string,
): SafeParseResult<Value, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Value$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Value' from JSON`,
  );
}

/** @internal */
export const SearchResponseRange$inboundSchema: z.ZodType<
  SearchResponseRange,
  z.ZodTypeDef,
  unknown
> = z.object({
  from: z.number().optional(),
  to: z.number().optional(),
  count: z.number().int().optional(),
});

/** @internal */
export type SearchResponseRange$Outbound = {
  from?: number | undefined;
  to?: number | undefined;
  count?: number | undefined;
};

/** @internal */
export const SearchResponseRange$outboundSchema: z.ZodType<
  SearchResponseRange$Outbound,
  z.ZodTypeDef,
  SearchResponseRange
> = z.object({
  from: z.number().optional(),
  to: z.number().optional(),
  count: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchResponseRange$ {
  /** @deprecated use `SearchResponseRange$inboundSchema` instead. */
  export const inboundSchema = SearchResponseRange$inboundSchema;
  /** @deprecated use `SearchResponseRange$outboundSchema` instead. */
  export const outboundSchema = SearchResponseRange$outboundSchema;
  /** @deprecated use `SearchResponseRange$Outbound` instead. */
  export type Outbound = SearchResponseRange$Outbound;
}

export function searchResponseRangeToJSON(
  searchResponseRange: SearchResponseRange,
): string {
  return JSON.stringify(
    SearchResponseRange$outboundSchema.parse(searchResponseRange),
  );
}

export function searchResponseRangeFromJSON(
  jsonString: string,
): SafeParseResult<SearchResponseRange, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchResponseRange$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchResponseRange' from JSON`,
  );
}

/** @internal */
export const Aggregations$inboundSchema: z.ZodType<
  Aggregations,
  z.ZodTypeDef,
  unknown
> = z.object({
  values: z.array(z.lazy(() => Value$inboundSchema)).optional(),
  ranges: z.array(z.lazy(() => SearchResponseRange$inboundSchema)).optional(),
});

/** @internal */
export type Aggregations$Outbound = {
  values?: Array<Value$Outbound> | undefined;
  ranges?: Array<SearchResponseRange$Outbound> | undefined;
};

/** @internal */
export const Aggregations$outboundSchema: z.ZodType<
  Aggregations$Outbound,
  z.ZodTypeDef,
  Aggregations
> = z.object({
  values: z.array(z.lazy(() => Value$outboundSchema)).optional(),
  ranges: z.array(z.lazy(() => SearchResponseRange$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Aggregations$ {
  /** @deprecated use `Aggregations$inboundSchema` instead. */
  export const inboundSchema = Aggregations$inboundSchema;
  /** @deprecated use `Aggregations$outboundSchema` instead. */
  export const outboundSchema = Aggregations$outboundSchema;
  /** @deprecated use `Aggregations$Outbound` instead. */
  export type Outbound = Aggregations$Outbound;
}

export function aggregationsToJSON(aggregations: Aggregations): string {
  return JSON.stringify(Aggregations$outboundSchema.parse(aggregations));
}

export function aggregationsFromJSON(
  jsonString: string,
): SafeParseResult<Aggregations, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Aggregations$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Aggregations' from JSON`,
  );
}

/** @internal */
export const SearchResponse$inboundSchema: z.ZodType<
  SearchResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  total_count: z.number().int().optional(),
  time: z.number().int().optional(),
  resources: z.array(z.lazy(() => Resource$inboundSchema)).optional(),
  next_cursor: z.nullable(z.string()).optional(),
  aggregations: z.lazy(() => Aggregations$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "total_count": "totalCount",
    "next_cursor": "nextCursor",
  });
});

/** @internal */
export type SearchResponse$Outbound = {
  total_count?: number | undefined;
  time?: number | undefined;
  resources?: Array<Resource$Outbound> | undefined;
  next_cursor?: string | null | undefined;
  aggregations?: Aggregations$Outbound | undefined;
};

/** @internal */
export const SearchResponse$outboundSchema: z.ZodType<
  SearchResponse$Outbound,
  z.ZodTypeDef,
  SearchResponse
> = z.object({
  totalCount: z.number().int().optional(),
  time: z.number().int().optional(),
  resources: z.array(z.lazy(() => Resource$outboundSchema)).optional(),
  nextCursor: z.nullable(z.string()).optional(),
  aggregations: z.lazy(() => Aggregations$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    totalCount: "total_count",
    nextCursor: "next_cursor",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchResponse$ {
  /** @deprecated use `SearchResponse$inboundSchema` instead. */
  export const inboundSchema = SearchResponse$inboundSchema;
  /** @deprecated use `SearchResponse$outboundSchema` instead. */
  export const outboundSchema = SearchResponse$outboundSchema;
  /** @deprecated use `SearchResponse$Outbound` instead. */
  export type Outbound = SearchResponse$Outbound;
}

export function searchResponseToJSON(searchResponse: SearchResponse): string {
  return JSON.stringify(SearchResponse$outboundSchema.parse(searchResponse));
}

export function searchResponseFromJSON(
  jsonString: string,
): SafeParseResult<SearchResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchResponse' from JSON`,
  );
}
