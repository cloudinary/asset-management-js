/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Included if 'context=true' parameter is used.
 */
export type InfoContext = {
  custom?: { [k: string]: any } | undefined;
};

export type InfoModeration = {
  kind?: string | undefined;
  status?: string | undefined;
  updatedAt?: Date | undefined;
};

export type InfoAccessControl = {};

export type Derivative = {
  /**
   * The unique identifier of the derived resource
   */
  id?: string | undefined;
  /**
   * The transformation string that was applied
   */
  transformation?: string | undefined;
  /**
   * The unique signature of the transformation
   */
  transformationSignature?: string | undefined;
  /**
   * The secure URL for accessing the derived resource
   */
  secureUrl?: string | undefined;
};

export type Info = {
  assetId?: string | undefined;
  publicId?: string | undefined;
  assetFolder?: string | undefined;
  displayName?: string | undefined;
  folder?: string | undefined;
  filename?: string | undefined;
  format?: string | undefined;
  version?: number | undefined;
  resourceType?: string | undefined;
  type?: string | undefined;
  createdAt?: Date | undefined;
  uploadedAt?: Date | undefined;
  bytes?: number | undefined;
  backupBytes?: number | undefined;
  width?: number | null | undefined;
  height?: number | null | undefined;
  aspectRatio?: number | null | undefined;
  pixels?: number | null | undefined;
  /**
   * Included if 'tags=true' parameter is used.
   */
  tags?: Array<string> | undefined;
  /**
   * Included if 'context=true' parameter is used.
   */
  context?: InfoContext | undefined;
  metadata?: { [k: string]: any } | undefined;
  /**
   * The type of moderation applied to the asset.
   */
  moderationKind?: string | undefined;
  /**
   * The current status of the moderation process for the asset.
   */
  moderationStatus?: string | undefined;
  /**
   * Included if 'moderations=true' parameter is used.
   */
  moderation?: Array<InfoModeration> | undefined;
  backup?: boolean | undefined;
  accessMode?: string | undefined;
  url?: string | undefined;
  secureUrl?: string | undefined;
  status?: string | undefined;
  accessControl?: Array<InfoAccessControl> | null | undefined;
  etag?: string | undefined;
  /**
   * Included if 'derived=true' parameter is used. Array of derived resources.
   */
  derivatives?: Array<Derivative> | undefined;
};

/** @internal */
export const InfoContext$inboundSchema: z.ZodType<
  InfoContext,
  z.ZodTypeDef,
  unknown
> = z.object({
  custom: z.record(z.any()).optional(),
});

/** @internal */
export type InfoContext$Outbound = {
  custom?: { [k: string]: any } | undefined;
};

/** @internal */
export const InfoContext$outboundSchema: z.ZodType<
  InfoContext$Outbound,
  z.ZodTypeDef,
  InfoContext
> = z.object({
  custom: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InfoContext$ {
  /** @deprecated use `InfoContext$inboundSchema` instead. */
  export const inboundSchema = InfoContext$inboundSchema;
  /** @deprecated use `InfoContext$outboundSchema` instead. */
  export const outboundSchema = InfoContext$outboundSchema;
  /** @deprecated use `InfoContext$Outbound` instead. */
  export type Outbound = InfoContext$Outbound;
}

export function infoContextToJSON(infoContext: InfoContext): string {
  return JSON.stringify(InfoContext$outboundSchema.parse(infoContext));
}

export function infoContextFromJSON(
  jsonString: string,
): SafeParseResult<InfoContext, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InfoContext$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InfoContext' from JSON`,
  );
}

/** @internal */
export const InfoModeration$inboundSchema: z.ZodType<
  InfoModeration,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: z.string().optional(),
  status: z.string().optional(),
  updated_at: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "updated_at": "updatedAt",
  });
});

/** @internal */
export type InfoModeration$Outbound = {
  kind?: string | undefined;
  status?: string | undefined;
  updated_at?: string | undefined;
};

/** @internal */
export const InfoModeration$outboundSchema: z.ZodType<
  InfoModeration$Outbound,
  z.ZodTypeDef,
  InfoModeration
> = z.object({
  kind: z.string().optional(),
  status: z.string().optional(),
  updatedAt: z.date().transform(v => v.toISOString()).optional(),
}).transform((v) => {
  return remap$(v, {
    updatedAt: "updated_at",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InfoModeration$ {
  /** @deprecated use `InfoModeration$inboundSchema` instead. */
  export const inboundSchema = InfoModeration$inboundSchema;
  /** @deprecated use `InfoModeration$outboundSchema` instead. */
  export const outboundSchema = InfoModeration$outboundSchema;
  /** @deprecated use `InfoModeration$Outbound` instead. */
  export type Outbound = InfoModeration$Outbound;
}

export function infoModerationToJSON(infoModeration: InfoModeration): string {
  return JSON.stringify(InfoModeration$outboundSchema.parse(infoModeration));
}

export function infoModerationFromJSON(
  jsonString: string,
): SafeParseResult<InfoModeration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InfoModeration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InfoModeration' from JSON`,
  );
}

/** @internal */
export const InfoAccessControl$inboundSchema: z.ZodType<
  InfoAccessControl,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type InfoAccessControl$Outbound = {};

/** @internal */
export const InfoAccessControl$outboundSchema: z.ZodType<
  InfoAccessControl$Outbound,
  z.ZodTypeDef,
  InfoAccessControl
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InfoAccessControl$ {
  /** @deprecated use `InfoAccessControl$inboundSchema` instead. */
  export const inboundSchema = InfoAccessControl$inboundSchema;
  /** @deprecated use `InfoAccessControl$outboundSchema` instead. */
  export const outboundSchema = InfoAccessControl$outboundSchema;
  /** @deprecated use `InfoAccessControl$Outbound` instead. */
  export type Outbound = InfoAccessControl$Outbound;
}

export function infoAccessControlToJSON(
  infoAccessControl: InfoAccessControl,
): string {
  return JSON.stringify(
    InfoAccessControl$outboundSchema.parse(infoAccessControl),
  );
}

export function infoAccessControlFromJSON(
  jsonString: string,
): SafeParseResult<InfoAccessControl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InfoAccessControl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InfoAccessControl' from JSON`,
  );
}

/** @internal */
export const Derivative$inboundSchema: z.ZodType<
  Derivative,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  transformation: z.string().optional(),
  transformation_signature: z.string().optional(),
  secure_url: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "transformation_signature": "transformationSignature",
    "secure_url": "secureUrl",
  });
});

/** @internal */
export type Derivative$Outbound = {
  id?: string | undefined;
  transformation?: string | undefined;
  transformation_signature?: string | undefined;
  secure_url?: string | undefined;
};

/** @internal */
export const Derivative$outboundSchema: z.ZodType<
  Derivative$Outbound,
  z.ZodTypeDef,
  Derivative
> = z.object({
  id: z.string().optional(),
  transformation: z.string().optional(),
  transformationSignature: z.string().optional(),
  secureUrl: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    transformationSignature: "transformation_signature",
    secureUrl: "secure_url",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Derivative$ {
  /** @deprecated use `Derivative$inboundSchema` instead. */
  export const inboundSchema = Derivative$inboundSchema;
  /** @deprecated use `Derivative$outboundSchema` instead. */
  export const outboundSchema = Derivative$outboundSchema;
  /** @deprecated use `Derivative$Outbound` instead. */
  export type Outbound = Derivative$Outbound;
}

export function derivativeToJSON(derivative: Derivative): string {
  return JSON.stringify(Derivative$outboundSchema.parse(derivative));
}

export function derivativeFromJSON(
  jsonString: string,
): SafeParseResult<Derivative, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Derivative$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Derivative' from JSON`,
  );
}

/** @internal */
export const Info$inboundSchema: z.ZodType<Info, z.ZodTypeDef, unknown> = z
  .object({
    asset_id: z.string().optional(),
    public_id: z.string().optional(),
    asset_folder: z.string().optional(),
    display_name: z.string().optional(),
    folder: z.string().optional(),
    filename: z.string().optional(),
    format: z.string().optional(),
    version: z.number().int().optional(),
    resource_type: z.string().optional(),
    type: z.string().optional(),
    created_at: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ).optional(),
    uploaded_at: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ).optional(),
    bytes: z.number().int().optional(),
    backup_bytes: z.number().int().optional(),
    width: z.nullable(z.number().int()).optional(),
    height: z.nullable(z.number().int()).optional(),
    aspect_ratio: z.nullable(z.number()).optional(),
    pixels: z.nullable(z.number().int()).optional(),
    tags: z.array(z.string()).optional(),
    context: z.lazy(() => InfoContext$inboundSchema).optional(),
    metadata: z.record(z.any()).optional(),
    moderation_kind: z.string().optional(),
    moderation_status: z.string().optional(),
    moderation: z.array(z.lazy(() => InfoModeration$inboundSchema)).optional(),
    backup: z.boolean().optional(),
    access_mode: z.string().optional(),
    url: z.string().optional(),
    secure_url: z.string().optional(),
    status: z.string().optional(),
    access_control: z.nullable(
      z.array(z.lazy(() => InfoAccessControl$inboundSchema)),
    ).optional(),
    etag: z.string().optional(),
    derivatives: z.array(z.lazy(() => Derivative$inboundSchema)).optional(),
  }).transform((v) => {
    return remap$(v, {
      "asset_id": "assetId",
      "public_id": "publicId",
      "asset_folder": "assetFolder",
      "display_name": "displayName",
      "resource_type": "resourceType",
      "created_at": "createdAt",
      "uploaded_at": "uploadedAt",
      "backup_bytes": "backupBytes",
      "aspect_ratio": "aspectRatio",
      "moderation_kind": "moderationKind",
      "moderation_status": "moderationStatus",
      "access_mode": "accessMode",
      "secure_url": "secureUrl",
      "access_control": "accessControl",
    });
  });

/** @internal */
export type Info$Outbound = {
  asset_id?: string | undefined;
  public_id?: string | undefined;
  asset_folder?: string | undefined;
  display_name?: string | undefined;
  folder?: string | undefined;
  filename?: string | undefined;
  format?: string | undefined;
  version?: number | undefined;
  resource_type?: string | undefined;
  type?: string | undefined;
  created_at?: string | undefined;
  uploaded_at?: string | undefined;
  bytes?: number | undefined;
  backup_bytes?: number | undefined;
  width?: number | null | undefined;
  height?: number | null | undefined;
  aspect_ratio?: number | null | undefined;
  pixels?: number | null | undefined;
  tags?: Array<string> | undefined;
  context?: InfoContext$Outbound | undefined;
  metadata?: { [k: string]: any } | undefined;
  moderation_kind?: string | undefined;
  moderation_status?: string | undefined;
  moderation?: Array<InfoModeration$Outbound> | undefined;
  backup?: boolean | undefined;
  access_mode?: string | undefined;
  url?: string | undefined;
  secure_url?: string | undefined;
  status?: string | undefined;
  access_control?: Array<InfoAccessControl$Outbound> | null | undefined;
  etag?: string | undefined;
  derivatives?: Array<Derivative$Outbound> | undefined;
};

/** @internal */
export const Info$outboundSchema: z.ZodType<Info$Outbound, z.ZodTypeDef, Info> =
  z.object({
    assetId: z.string().optional(),
    publicId: z.string().optional(),
    assetFolder: z.string().optional(),
    displayName: z.string().optional(),
    folder: z.string().optional(),
    filename: z.string().optional(),
    format: z.string().optional(),
    version: z.number().int().optional(),
    resourceType: z.string().optional(),
    type: z.string().optional(),
    createdAt: z.date().transform(v => v.toISOString()).optional(),
    uploadedAt: z.date().transform(v => v.toISOString()).optional(),
    bytes: z.number().int().optional(),
    backupBytes: z.number().int().optional(),
    width: z.nullable(z.number().int()).optional(),
    height: z.nullable(z.number().int()).optional(),
    aspectRatio: z.nullable(z.number()).optional(),
    pixels: z.nullable(z.number().int()).optional(),
    tags: z.array(z.string()).optional(),
    context: z.lazy(() => InfoContext$outboundSchema).optional(),
    metadata: z.record(z.any()).optional(),
    moderationKind: z.string().optional(),
    moderationStatus: z.string().optional(),
    moderation: z.array(z.lazy(() => InfoModeration$outboundSchema)).optional(),
    backup: z.boolean().optional(),
    accessMode: z.string().optional(),
    url: z.string().optional(),
    secureUrl: z.string().optional(),
    status: z.string().optional(),
    accessControl: z.nullable(
      z.array(z.lazy(() => InfoAccessControl$outboundSchema)),
    ).optional(),
    etag: z.string().optional(),
    derivatives: z.array(z.lazy(() => Derivative$outboundSchema)).optional(),
  }).transform((v) => {
    return remap$(v, {
      assetId: "asset_id",
      publicId: "public_id",
      assetFolder: "asset_folder",
      displayName: "display_name",
      resourceType: "resource_type",
      createdAt: "created_at",
      uploadedAt: "uploaded_at",
      backupBytes: "backup_bytes",
      aspectRatio: "aspect_ratio",
      moderationKind: "moderation_kind",
      moderationStatus: "moderation_status",
      accessMode: "access_mode",
      secureUrl: "secure_url",
      accessControl: "access_control",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Info$ {
  /** @deprecated use `Info$inboundSchema` instead. */
  export const inboundSchema = Info$inboundSchema;
  /** @deprecated use `Info$outboundSchema` instead. */
  export const outboundSchema = Info$outboundSchema;
  /** @deprecated use `Info$Outbound` instead. */
  export type Outbound = Info$Outbound;
}

export function infoToJSON(info: Info): string {
  return JSON.stringify(Info$outboundSchema.parse(info));
}

export function infoFromJSON(
  jsonString: string,
): SafeParseResult<Info, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Info$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Info' from JSON`,
  );
}
