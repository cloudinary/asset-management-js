/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { uploadDestroyAsset } from "../funcs/uploadDestroyAsset.js";
import { uploadText } from "../funcs/uploadText.js";
import { UploadAcceptEnum, uploadUpload } from "../funcs/uploadUpload.js";
import {
  UploadChunkAcceptEnum,
  uploadUploadChunk,
} from "../funcs/uploadUploadChunk.js";
import {
  UploadNoResourceTypeAcceptEnum,
  uploadUploadNoResourceType,
} from "../funcs/uploadUploadNoResourceType.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export { UploadAcceptEnum } from "../funcs/uploadUpload.js";

export { UploadNoResourceTypeAcceptEnum } from "../funcs/uploadUploadNoResourceType.js";

export { UploadChunkAcceptEnum } from "../funcs/uploadUploadChunk.js";

export class Upload extends ClientSDK {
  /**
   * Uploads media assets (images, videos, raw files) to your Cloudinary product environment
   *
   * @remarks
   * Uploads media assets (images, videos, raw files) to your Cloudinary product environment. The file is securely stored
   * in the cloud with backup and revision history. Cloudinary automatically analyzes and saves important data about each
   * asset, such as format, size, resolution, and prominent colors, which is indexed to enable searching on those attributes.
   *
   * Supports uploading from:
   * - Local file paths (SDKs/MCP server only). For MCP server path MUST start with file://
   * - Remote HTTP/HTTPS URLs
   * - Base64 Data URIs (max ~60 MB)
   * - Private storage buckets (S3 or Google Storage)
   * - FTP addresses
   *
   * The uploaded asset is immediately available for transformation and delivery upon successful upload.
   */
  async upload(
    resourceType: components.UploadResourceType | undefined,
    uploadRequest: components.UploadRequest,
    options?: RequestOptions & { acceptHeaderOverride?: UploadAcceptEnum },
  ): Promise<operations.UploadResponse> {
    return unwrapAsync(uploadUpload(
      this,
      resourceType,
      uploadRequest,
      options,
    ));
  }

  /**
   * Upload with automatic file type detection
   *
   * @remarks
   * Uploads a file to Cloudinary. The file type is automatically detected based on its content, so you don't need to specify the type manually.
   */
  async uploadNoResourceType(
    request: components.UploadRequest,
    options?: RequestOptions & {
      acceptHeaderOverride?: UploadNoResourceTypeAcceptEnum;
    },
  ): Promise<operations.UploadNoResourceTypeResponse> {
    return unwrapAsync(uploadUploadNoResourceType(
      this,
      request,
      options,
    ));
  }

  /**
   * Upload a single chunk of a large file
   *
   * @remarks
   * Uploads a single chunk of a large file as part of a chunked upload process. This enables efficient upload of
   * large files with the ability to resume interrupted uploads. Each request uploads one chunk of the file.
   * It is required for any files that are larger than 100 MB. This is often relevant for video files, as they
   * tend to have larger file sizes. Minimum chunk size is 5 MB.
   */
  async uploadChunk(
    resourceType: components.UploadResourceType | undefined,
    contentRange: string,
    xUniqueUploadId: string,
    uploadRequest: components.UploadRequest,
    options?: RequestOptions & { acceptHeaderOverride?: UploadChunkAcceptEnum },
  ): Promise<operations.UploadChunkResponse> {
    return unwrapAsync(uploadUploadChunk(
      this,
      resourceType,
      contentRange,
      xUniqueUploadId,
      uploadRequest,
      options,
    ));
  }

  /**
   * Destroys an asset/resource
   */
  async destroyAsset(
    resourceType: components.ResourceType,
    publicId: string,
    invalidate?: boolean | undefined,
    options?: RequestOptions,
  ): Promise<operations.DestroyAssetResponse> {
    return unwrapAsync(uploadDestroyAsset(
      this,
      resourceType,
      publicId,
      invalidate,
      options,
    ));
  }

  /**
   * Create image from text
   *
   * @remarks
   * Dynamically generates an image from a specified text string.
   */
  async text(
    resourceType: operations.TextResourceType,
    requestBody: operations.TextRequestBody,
    options?: RequestOptions,
  ): Promise<operations.TextResponse> {
    return unwrapAsync(uploadText(
      this,
      resourceType,
      requestBody,
      options,
    ));
  }
}
