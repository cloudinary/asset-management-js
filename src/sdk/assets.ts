/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { assetsDeleteBackupVersions } from "../funcs/assetsDeleteBackupVersions.js";
import { assetsDeleteResourcesByPublicId } from "../funcs/assetsDeleteResourcesByPublicId.js";
import { assetsDerivedDestroy } from "../funcs/assetsDerivedDestroy.js";
import { assetsDestroyByAssetId } from "../funcs/assetsDestroyByAssetId.js";
import {
  assetsDownloadAsset,
  DownloadAssetAcceptEnum,
} from "../funcs/assetsDownloadAsset.js";
import {
  assetsDownloadBackupAsset,
  DownloadBackupAssetAcceptEnum,
} from "../funcs/assetsDownloadBackupAsset.js";
import { assetsExplicitAsset } from "../funcs/assetsExplicitAsset.js";
import {
  assetsGenerateArchive,
  GenerateArchiveAcceptEnum,
} from "../funcs/assetsGenerateArchive.js";
import { assetsGetResourceByAssetId } from "../funcs/assetsGetResourceByAssetId.js";
import { assetsGetResourceByPublicId } from "../funcs/assetsGetResourceByPublicId.js";
import { assetsListImages } from "../funcs/assetsListImages.js";
import { assetsListRawFiles } from "../funcs/assetsListRawFiles.js";
import { assetsListResourcesByAssetFolder } from "../funcs/assetsListResourcesByAssetFolder.js";
import { assetsListResourcesByAssetIDs } from "../funcs/assetsListResourcesByAssetIDs.js";
import { assetsListResourcesByContext } from "../funcs/assetsListResourcesByContext.js";
import { assetsListResourcesByModerationKindAndStatus } from "../funcs/assetsListResourcesByModerationKindAndStatus.js";
import { assetsListResourceTags } from "../funcs/assetsListResourceTags.js";
import { assetsListResourceTypes } from "../funcs/assetsListResourceTypes.js";
import { assetsListVideos } from "../funcs/assetsListVideos.js";
import { assetsRenameAsset } from "../funcs/assetsRenameAsset.js";
import { assetsRestoreResourcesByAssetIDs } from "../funcs/assetsRestoreResourcesByAssetIDs.js";
import { assetsUpdateResourceByAssetId } from "../funcs/assetsUpdateResourceByAssetId.js";
import { assetsUpdateResourceByPublicId } from "../funcs/assetsUpdateResourceByPublicId.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export { DownloadAssetAcceptEnum } from "../funcs/assetsDownloadAsset.js";

export { GenerateArchiveAcceptEnum } from "../funcs/assetsGenerateArchive.js";

export { DownloadBackupAssetAcceptEnum } from "../funcs/assetsDownloadBackupAsset.js";

export class Assets extends ClientSDK {
  /**
   * Updates an existing asset's identifier and optionally other metadata in your Cloudinary account
   */
  async renameAsset(
    resourceType: operations.RenameAssetResourceType,
    requestBody: operations.RenameAssetRequestBody,
    options?: RequestOptions,
  ): Promise<components.UploadResponse> {
    return unwrapAsync(assetsRenameAsset(
      this,
      resourceType,
      requestBody,
      options,
    ));
  }

  /**
   * Generates a download link for a specific asset (image)
   */
  async downloadAsset(
    resourceType: components.ResourceTypeParameter,
    publicId: string,
    apiKey: string,
    signature: string,
    timestamp: number,
    format?: string | undefined,
    type?: operations.DownloadAssetType | undefined,
    expiresAt?: number | undefined,
    attachment?: boolean | undefined,
    targetFilename?: string | undefined,
    transformation?: string | undefined,
    options?: RequestOptions & {
      acceptHeaderOverride?: DownloadAssetAcceptEnum;
    },
  ): Promise<operations.DownloadAssetResponse> {
    return unwrapAsync(assetsDownloadAsset(
      this,
      resourceType,
      publicId,
      apiKey,
      signature,
      timestamp,
      format,
      type,
      expiresAt,
      attachment,
      targetFilename,
      transformation,
      options,
    ));
  }

  /**
   * Apply operations on an existing asset
   *
   * @remarks
   * Applies actions such as transformations, tags, or metadata updates to an existing asset without re-uploading it.
   * This is useful for applying new transformations, adding tags, or updating metadata on assets that are already in your cloud.
   */
  async explicitAsset(
    resourceType: operations.ExplicitAssetResourceType,
    requestBody: operations.ExplicitAssetRequestBody,
    options?: RequestOptions,
  ): Promise<components.UploadResponse> {
    return unwrapAsync(assetsExplicitAsset(
      this,
      resourceType,
      requestBody,
      options,
    ));
  }

  /**
   * Creates an archive (ZIP or TGZ file) that contains a set of assets from
   *
   * @remarks
   * Creates a downloadable ZIP or other archive format containing the specified resources.
   */
  async generateArchive(
    resourceType: operations.GenerateArchiveResourceType,
    requestBody: operations.GenerateArchiveRequestBody,
    options?: RequestOptions & {
      acceptHeaderOverride?: GenerateArchiveAcceptEnum;
    },
  ): Promise<operations.GenerateArchiveResponse> {
    return unwrapAsync(assetsGenerateArchive(
      this,
      resourceType,
      requestBody,
      options,
    ));
  }

  /**
   * Download a backup copy of an asset
   */
  async downloadBackupAsset(
    assetId: string,
    versionId: string,
    apiKey: string,
    signature: string,
    timestamp: number,
    options?: RequestOptions & {
      acceptHeaderOverride?: DownloadBackupAssetAcceptEnum;
    },
  ): Promise<operations.DownloadBackupAssetResponse> {
    return unwrapAsync(assetsDownloadBackupAsset(
      this,
      assetId,
      versionId,
      apiKey,
      signature,
      timestamp,
      options,
    ));
  }

  /**
   * Delete asset by asset-id
   *
   * @remarks
   * Deletes an asset using its asset ID. This endpoint replaces the legacy /resources/by_asset_id endpoint.
   * Returns the deletion status and asset folder information when folder decoupling is enabled.
   */
  async destroyByAssetId(
    request: components.DestroyRequest,
    options?: RequestOptions,
  ): Promise<components.DestroyResponse> {
    return unwrapAsync(assetsDestroyByAssetId(
      this,
      request,
      options,
    ));
  }

  /**
   * Get resource types
   *
   * @remarks
   * Returns a list of all resource types that correspond to assets currently in your product environment.
   */
  async listResourceTypes(
    request: operations.ListResourceTypesRequest,
    options?: RequestOptions,
  ): Promise<operations.ListResourceTypesResponse> {
    return unwrapAsync(assetsListResourceTypes(
      this,
      request,
      options,
    ));
  }

  /**
   * Get image assets
   *
   * @remarks
   * Retrieves a list of image assets. Results can be filtered by various criteria like tags, moderation status, prefix, or specific public IDs.
   */
  async listImages(
    type?: operations.ListImagesType | undefined,
    prefix?: string | undefined,
    publicIds?: Array<string> | undefined,
    tags?: boolean | undefined,
    nextCursor?: string | undefined,
    maxResults?: number | undefined,
    direction?: components.Direction | undefined,
    startAt?: Date | undefined,
    fields?: Array<components.FieldsSpec> | undefined,
    options?: RequestOptions,
  ): Promise<components.ListResponse> {
    return unwrapAsync(assetsListImages(
      this,
      type,
      prefix,
      publicIds,
      tags,
      nextCursor,
      maxResults,
      direction,
      startAt,
      fields,
      options,
    ));
  }

  /**
   * Get video assets
   *
   * @remarks
   * Retrieves a list of video assets. Results can be filtered by various criteria like tags, moderation status, prefix, or specific public IDs.
   */
  async listVideos(
    type?: operations.ListVideosType | undefined,
    prefix?: string | undefined,
    publicIds?: Array<string> | undefined,
    tags?: boolean | undefined,
    nextCursor?: string | undefined,
    maxResults?: number | undefined,
    direction?: components.Direction | undefined,
    startAt?: Date | undefined,
    fields?: Array<components.FieldsSpec> | undefined,
    options?: RequestOptions,
  ): Promise<components.ListResponse> {
    return unwrapAsync(assetsListVideos(
      this,
      type,
      prefix,
      publicIds,
      tags,
      nextCursor,
      maxResults,
      direction,
      startAt,
      fields,
      options,
    ));
  }

  /**
   * Get raw assets
   *
   * @remarks
   * Retrieves a list of raw assets. Results can be filtered by various criteria like tags, moderation status, prefix, or specific public IDs.
   */
  async listRawFiles(
    type?: operations.ListRawFilesType | undefined,
    prefix?: string | undefined,
    publicIds?: Array<string> | undefined,
    tags?: boolean | undefined,
    nextCursor?: string | undefined,
    maxResults?: number | undefined,
    direction?: components.Direction | undefined,
    startAt?: Date | undefined,
    fields?: Array<components.FieldsSpec> | undefined,
    options?: RequestOptions,
  ): Promise<components.ListResponse> {
    return unwrapAsync(assetsListRawFiles(
      this,
      type,
      prefix,
      publicIds,
      tags,
      nextCursor,
      maxResults,
      direction,
      startAt,
      fields,
      options,
    ));
  }

  /**
   * Get resources by asset folder
   *
   * @remarks
   * Retrieves a list of resources within a specific asset folder. Requires folder decoupling to be enabled.
   */
  async listResourcesByAssetFolder(
    assetFolder: string,
    resourceType?:
      | operations.ListResourcesByAssetFolderResourceType
      | undefined,
    nextCursor?: string | undefined,
    maxResults?: number | undefined,
    direction?: components.Direction | undefined,
    fields?: Array<components.FieldsSpec> | undefined,
    options?: RequestOptions,
  ): Promise<components.ListResponse> {
    return unwrapAsync(assetsListResourcesByAssetFolder(
      this,
      assetFolder,
      resourceType,
      nextCursor,
      maxResults,
      direction,
      fields,
      options,
    ));
  }

  /**
   * Get resources by asset IDs
   *
   * @remarks
   * Retrieves details for specific resources using their asset IDs (or external IDs).
   */
  async listResourcesByAssetIDs(
    assetIds: Array<string>,
    resourceType?: operations.ListResourcesByAssetIDsResourceType | undefined,
    fields?: Array<components.FieldsSpec> | undefined,
    options?: RequestOptions,
  ): Promise<components.ListResponse> {
    return unwrapAsync(assetsListResourcesByAssetIDs(
      this,
      assetIds,
      resourceType,
      fields,
      options,
    ));
  }

  /**
   * Get resources by context
   *
   * @remarks
   * Retrieves resources matching specific context key/value pairs.
   */
  async listResourcesByContext(
    resourceType: components.ResourceTypeParameter,
    key: string,
    value?: string | undefined,
    nextCursor?: string | undefined,
    maxResults?: number | undefined,
    direction?: components.Direction | undefined,
    fields?: Array<components.FieldsSpec> | undefined,
    options?: RequestOptions,
  ): Promise<components.ListResponse> {
    return unwrapAsync(assetsListResourcesByContext(
      this,
      resourceType,
      key,
      value,
      nextCursor,
      maxResults,
      direction,
      fields,
      options,
    ));
  }

  /**
   * Get resources by moderation kind and status
   *
   * @remarks
   * Retrieves resources matching specific moderation kind and status.
   */
  async listResourcesByModerationKindAndStatus(
    resourceType: components.ResourceTypeParameter,
    moderationKind: operations.ModerationKind,
    moderationStatus: operations.ModerationStatus,
    fields?: Array<components.FieldsSpec> | undefined,
    nextCursor?: string | undefined,
    maxResults?: number | undefined,
    direction?: components.Direction | undefined,
    options?: RequestOptions,
  ): Promise<components.ListResponse> {
    return unwrapAsync(assetsListResourcesByModerationKindAndStatus(
      this,
      resourceType,
      moderationKind,
      moderationStatus,
      fields,
      nextCursor,
      maxResults,
      direction,
      options,
    ));
  }

  /**
   * Restore assets
   *
   * @remarks
   * Restores one or more resources from backup using their asset IDs. Can optionally specify versions to restore.
   */
  async restoreResourcesByAssetIDs(
    request: operations.RestoreResourcesByAssetIDsRequest,
    options?: RequestOptions,
  ): Promise<{ [k: string]: components.RestoreResponseUnion }> {
    return unwrapAsync(assetsRestoreResourcesByAssetIDs(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete resources by public ID
   *
   * @remarks
   * Deletes assets uploaded to your product environment, identified by their public IDs.
   */
  async deleteResourcesByPublicId(
    resourceType: components.ResourceTypeParameter,
    type: operations.DeleteResourcesByPublicIdType,
    deleteResourceByPublicIdsRequest:
      components.DeleteResourceByPublicIdsRequestUnion,
    options?: RequestOptions,
  ): Promise<operations.DeleteResourcesByPublicIdResponse> {
    return unwrapAsync(assetsDeleteResourcesByPublicId(
      this,
      resourceType,
      type,
      deleteResourceByPublicIdsRequest,
      options,
    ));
  }

  /**
   * Get resource by public ID
   *
   * @remarks
   * Returns the details of a single resource specified by its public ID.
   */
  async getResourceByPublicId(
    resourceType: components.ResourceTypeParameter,
    type: operations.GetResourceByPublicIdType,
    publicId: string,
    colors?: boolean | undefined,
    mediaMetadata?: boolean | undefined,
    faces?: boolean | undefined,
    qualityAnalysis?: boolean | undefined,
    accessibilityAnalysis?: boolean | undefined,
    pages?: boolean | undefined,
    phash?: boolean | undefined,
    coordinates?: boolean | undefined,
    versions?: boolean | undefined,
    maxResults?: number | undefined,
    derivedNextCursor?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.Info> {
    return unwrapAsync(assetsGetResourceByPublicId(
      this,
      resourceType,
      type,
      publicId,
      colors,
      mediaMetadata,
      faces,
      qualityAnalysis,
      accessibilityAnalysis,
      pages,
      phash,
      coordinates,
      versions,
      maxResults,
      derivedNextCursor,
      options,
    ));
  }

  /**
   * Update asset by public ID
   *
   * @remarks
   * Updates one or more attributes of a specified resource (asset) identified by its public ID. Note that you can also update many attributes of an existing asset using the explicit method, which is not rate limited.
   */
  async updateResourceByPublicId(
    resourceType: components.ResourceTypeParameter,
    type: operations.UpdateResourceByPublicIdType,
    publicId: string,
    resourceUpdateRequest: components.ResourceUpdateRequest,
    options?: RequestOptions,
  ): Promise<components.Info> {
    return unwrapAsync(assetsUpdateResourceByPublicId(
      this,
      resourceType,
      type,
      publicId,
      resourceUpdateRequest,
      options,
    ));
  }

  /**
   * Get resource by asset ID
   *
   * @remarks
   * Returns the details of a single resource specified by its asset ID.
   */
  async getResourceByAssetId(
    assetId: string,
    colors?: boolean | undefined,
    mediaMetadata?: boolean | undefined,
    faces?: boolean | undefined,
    qualityAnalysis?: boolean | undefined,
    accessibilityAnalysis?: boolean | undefined,
    pages?: boolean | undefined,
    phash?: boolean | undefined,
    coordinates?: boolean | undefined,
    versions?: boolean | undefined,
    maxResults?: number | undefined,
    derivedNextCursor?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.Info> {
    return unwrapAsync(assetsGetResourceByAssetId(
      this,
      assetId,
      colors,
      mediaMetadata,
      faces,
      qualityAnalysis,
      accessibilityAnalysis,
      pages,
      phash,
      coordinates,
      versions,
      maxResults,
      derivedNextCursor,
      options,
    ));
  }

  /**
   * Updates an existing asset's metadata, tags, and other attributes using its asset ID
   *
   * @remarks
   * Updates one or more attributes of a specified resource (asset) by its asset ID. This enables you to update details of an asset by its unique and immutable identifier, regardless of public ID, display name, asset folder, resource type or deliver type. Note that you can also update many attributes of an existing asset using the explicit method, which is not rate-limited.
   */
  async updateResourceByAssetId(
    assetId: string,
    resourceUpdateRequest: components.ResourceUpdateRequest,
    options?: RequestOptions,
  ): Promise<components.Info> {
    return unwrapAsync(assetsUpdateResourceByAssetId(
      this,
      assetId,
      resourceUpdateRequest,
      options,
    ));
  }

  /**
   * Retrieves a list of tags currently applied to assets in your Cloudinary account
   *
   * @remarks
   * Retrieves a comprehensive list of all tags that exist in your product environment for assets of the specified type.
   *
   * [Cloudinary Admin API documentation](https://cloudinary.com/documentation/admin_api)
   */
  async listResourceTags(
    resourceType: components.ResourceTypeParameter,
    prefix?: string | undefined,
    nextCursor?: string | undefined,
    maxResults?: number | undefined,
    options?: RequestOptions,
  ): Promise<operations.ListResourceTagsResponse> {
    return unwrapAsync(assetsListResourceTags(
      this,
      resourceType,
      prefix,
      nextCursor,
      maxResults,
      options,
    ));
  }

  /**
   * Delete backed up versions
   *
   * @remarks
   * Deletes specific backed up versions of an asset identified by asset ID.
   * This operation is irreversible and deleted versions cannot be recovered.
   */
  async deleteBackupVersions(
    assetId: string,
    requestBody: operations.DeleteBackupVersionsRequestBody,
    options?: RequestOptions,
  ): Promise<operations.DeleteBackupVersionsResponse> {
    return unwrapAsync(assetsDeleteBackupVersions(
      this,
      assetId,
      requestBody,
      options,
    ));
  }

  /**
   * Delete derived resources
   *
   * @remarks
   * Deletes derived resources by derived resource ID
   */
  async derivedDestroy(
    request: components.DerivedDestroyRequest,
    options?: RequestOptions,
  ): Promise<components.DerivedDestroyResponse> {
    return unwrapAsync(assetsDerivedDestroy(
      this,
      request,
      options,
    ));
  }
}
