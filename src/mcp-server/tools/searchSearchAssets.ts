/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { searchSearchAssets } from "../../funcs/searchSearchAssets.js";
import * as components from "../../models/components/index.js";
import { formatResult, ToolDefinition } from "../tools.js";

const args = {
  request: components.SearchParameters$inboundSchema,
};

export const tool$searchSearchAssets: ToolDefinition<typeof args> = {
  name: "search-assets",
  description:
    `Purpose: Provides a powerful query interface to filter and retrieve assets (images, videos, raw files) in your account using a flexible expression language. The search-assets operation allows you to specify complex conditions (similar to a SQL or Lucene query) on asset fields such as public IDs, filenames, tags, folders, upload dates, file size, format, metadata, etc., and get back only the resources that meet those criteria. This is essentially Cloudinary's Search API, enabling sophisticated Digital Asset Management queries.
Usage: Use this when you need to find assets that meet specific conditions or combinations of conditions beyond simple listings. For example, "find all images tagged 'summer' uploaded last week larger than 2MB", or "videos longer than 30 seconds with format MP4 in a certain folder". It's ideal for building admin dashboards, search functionality in a media library, or anytime you need to filter resources by attributes. You can combine multiple filters with AND/OR logic, do prefix or wildcard searches, numeric ranges, date ranges, etc. The search expression language supports tokenized (contains) searches and exact matches on string fields, numerical comparisons, date comparisons, and more. (Boolean operators like AND, OR, NOT can be used to join sub-expressions as well.) Keep in mind that this is a rate-limited Admin API method, so it's not meant for high-volume public queries, but rather for backend or management use.
When Not to Use: If a simpler endpoint can achieve the goal (for example, listing all assets in a folder or retrieving a specific asset by ID), use that instead of executing a search query. The search API is very powerful but also more resource-intensive, so avoid using it unnecessarily (especially for frequent or simple operations that could be achieved with direct GET calls). Also, if your search can be done via tagging or structured metadata and you prefer to maintain those, consider whether you actually need complex queries. In short, don't use search-assets for every small retrieval when an exact fetch or a simpler list would do, to stay within rate limits and reduce complexity.
Output: Returns a JSON response containing the assets that match the search criteria and some summary information. The main part of the response is an array called \`resources\`, where each element is a resource (asset) object with its details (like it would appear in an Admin API listing â€” e.g., public_id, URL, format, dimensions, tags, context, etc., depending on what fields you requested to include). The response also includes: \`total_count\` (total number of matched assets), \`time\` (query execution time), \`next_cursor\` (if there are more results beyond the page limit), and any aggregation counts.
Searchable Fields and Filters: The query expression can utilize essentially any asset attribute. This includes standard fields like \`public_id\`, \`filename\`, \`folder\`, \`tags\`, \`context\` (key-value metadata), \`format\`, \`resource_type\`, \`uploaded_at\` (or \`created_at\`), file \`bytes\` (size), image/video dimensions (\`width\`, \`height\`, \`pixels\`), duration (for video), as well as structured metadata fields (\`metadata.<field_external_id>\`), moderation status, and more. Even internal or analysis-based fields can be used: e.g., \`face_count\`, \`colors\`, \`accessibility_analysis\` scores, \`quality_analysis\` scores, etc., for accounts with those features (these advanced fields require that you have enabled analysis on upload). *Full list of searchable fields:* - **Asset info:** \`public_id\`, \`filename\`, \`folder\`, \`asset_id\`, \`asset_folder\` (dynamic folders), \`format\`, \`resource_type\`, \`type\` (delivery type), \`uploaded_at\`/\`created_at\`, \`uploaded_by\` (if applicable), \`tags\`, \`context\` (use \`context.<key>\` for specific keys), \`metadata.<external_id>\` (for structured metadata fields), \`status\` (active/deleted). - **File characteristics:** \`bytes\` (file size), \`width\`, \`height\`, \`aspect_ratio\`, \`pixels\` (total pixels), \`duration\` (for video/audio length). - **Moderation and status:** \`moderation_status\` (e.g., approved/rejected), \`moderation_kind\` (which moderation service), \`access_mode\` (public or authenticated). - **Analysis & AI (Tier 2 features):** \`face_count\`, \`grayscale\` (boolean if image is grayscale), \`colors\` (contains a given color), \`illustration_score\`, \`accessibility_analysis.colorblind_accessibility_score\`, \`quality_analysis.color_score\`, \`quality_analysis.pixel_score\`, etc., as well as embedded \`image_metadata\` fields (EXIF/XMP data) and \`location\` (GPS coordinates).
Supported Operators: You can filter string fields by exact match (\`=\`) or tokenized (contains) match (\`:\`), numeric and date fields with comparison operators (\`=\`, \`>\`, \`>=\`, \`<\`, \`<=\`) and range syntax (\`[...]\` for inclusive ranges, \`{...}\` for exclusive ranges). String fields support wildcards for prefix/suffix searches (e.g., \`public_id:holiday*\` for prefix). You can also use negation to exclude terms (for example, prefixing with a minus: \`-tags:holiday\` means tag is not "holiday"). Boolean fields use \`=true\` or \`=false\`. Complex expressions can be built using parentheses and the logical operators AND, OR, NOT as needed (Cloudinary's search syntax will interpret space-separated terms as AND by default).
Sortable Fields: You can sort the results by a specified field in ascending or descending order. Common sortable fields include \`public_id\`, \`filename\`, \`created_at\`/\`uploaded_at\`, \`updated_at\` (last updated), \`bytes\` (file size), or other single-valued attributes like width or height. Multi-valued fields like tags or context keys are not typically used for sorting. If no sort is specified, results default to descending by creation date. You can specify multiple sort keys as an array of field-direction pairs (e.g., sort by format asc, then public_id asc).
Examples: Here are a few example search expressions (as they would be used in the \`expression\` parameter) illustrating different types of filters and operators: \`\`\`text tags: sale AND uploaded_at > 1d
`,
  scopes: ["librarian"],
  args,
  tool: async (client, args, ctx) => {
    const [result, apiCall] = await searchSearchAssets(
      client,
      args.request,
      { fetchOptions: { signal: ctx.signal } },
    ).$inspect();

    if (!result.ok) {
      return {
        content: [{ type: "text", text: result.error.message }],
        isError: true,
      };
    }

    const value = result.value;

    return formatResult(value, apiCall);
  },
};
