/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { uploadUpload } from "../../funcs/uploadUpload.js";
import * as components from "../../models/components/index.js";
import { formatResult, ToolDefinition } from "../tools.js";

const args = {
  resourceType: components.UploadResourceType$inboundSchema.default("auto"),
  uploadRequest: components.UploadRequest$inboundSchema,
};

export const tool$uploadUpload: ToolDefinition<typeof args> = {
  name: "upload-upload",
  description:
    `Purpose: Uploads media assets (images, videos, raw files) to your Cloudinary product environment with automatic format detection, metadata extraction, and immediate availability for transformation and delivery.
Usage: Use this to add new media assets to your cloud storage, whether from local files, remote URLs, Base64 data, or cloud storage buckets. Essential for content management systems, user uploads, and bulk media ingestion workflows.
Example request: POST with multipart/form-data containing file binary data, or JSON body like {"file": "https://example.com/image.jpg", "public_id": "sample", "folder": "products", "tags": "featured,electronics"}
Parameters: file(asset to upload - local path (For MCP server path MUST start with file://)/URL/Base64), public_id(custom identifier), folder(organization folder), tags(comma-separated labels), resource_type(image/video/raw), format(convert to specific format), transformation(apply on upload), overwrite(replace existing), notification_url(callback URL), context(key-value metadata), metadata(structured metadata), access_mode(public/authenticated), backup(enable versioning), faces(detect faces), colors(extract colors), quality_analysis(assess quality), auto_tagging(confidence threshold), moderation(content filtering)
When Not to Use: Don't use for assets that are already in cloud storage (use existing asset operations instead). Avoid for temporary files that don't need permanent storage. Don't use for very large files without chunked upload for files over 100MB.
Output: Returns comprehensive asset information: public_id(asset identifier), asset_id(unique asset ID), version(version number), resource_type(asset type), format(file format), created_at(upload timestamp), bytes(file size), width/height(dimensions for images/videos), url(public delivery URL), secure_url(HTTPS delivery URL), signature(validation signature), etag(entity tag), original_filename(source filename), tags(assigned tags array), context(metadata object), analysis results (colors, faces, moderation if requested)
Example output: {"public_id":"sample","asset_id":"abc123def456","version":1234567890,"resource_type":"image","format":"jpg","created_at":"2023-01-15T10:00:00Z","bytes":45231,"width":800,"height":600,"url":"http://res.cloudinary.com/demo/image/upload/v1234567890/sample.jpg","secure_url":"https://res.cloudinary.com/demo/image/upload/v1234567890/sample.jpg","signature":"abc123def456","etag":"def789ghi012","original_filename":"photo.jpg","tags":["featured","electronics"],"context":{"category":"product"}}
`,
  scopes: ["librarian", "builder"],
  args,
  tool: async (client, args, ctx) => {
    const [result, apiCall] = await uploadUpload(
      client,
      args.resourceType,
      args.uploadRequest,
      { fetchOptions: { signal: ctx.signal } },
    ).$inspect();

    if (!result.ok) {
      return {
        content: [{ type: "text", text: result.error.message }],
        isError: true,
      };
    }

    const value = result.value;

    return formatResult(value, apiCall);
  },
};
