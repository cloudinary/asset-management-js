/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { CloudinaryAssetMgmtCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import { CloudinaryAssetMgmtError } from "../models/errors/cloudinaryassetmgmterror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Searches for folders whose attributes match a given expression
 *
 * @remarks
 * Lists the folders that match the specified search expression. Limited to 2000 results. If no parameters are passed, returns the 50 most recently created folders in descending order of creation time.
 */
export function foldersSearchFolders(
  client: CloudinaryAssetMgmtCore,
  expression?: operations.ExpressionUnion | undefined,
  sortBy?: Array<string> | undefined,
  maxResults?: number | undefined,
  nextCursor?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    components.FoldersSearchResponse,
    | errors.ApiError
    | CloudinaryAssetMgmtError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    expression,
    sortBy,
    maxResults,
    nextCursor,
    options,
  ));
}

async function $do(
  client: CloudinaryAssetMgmtCore,
  expression?: operations.ExpressionUnion | undefined,
  sortBy?: Array<string> | undefined,
  maxResults?: number | undefined,
  nextCursor?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      components.FoldersSearchResponse,
      | errors.ApiError
      | CloudinaryAssetMgmtError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.SearchFoldersRequest = {
    expression: expression,
    sortBy: sortBy,
    maxResults: maxResults,
    nextCursor: nextCursor,
  };

  const parsed = safeParse(
    input,
    (value) => operations.SearchFoldersRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    cloud_name: encodeSimple("cloud_name", client._options.cloudName, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1_1/{cloud_name}/folders/search")(pathParams);

  const query = encodeFormQuery({
    "expression": payload.expression,
    "max_results": payload.max_results,
    "next_cursor": payload.next_cursor,
    "sort_by": payload.sort_by,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "searchFolders",
    oAuth2Scopes: [],

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    components.FoldersSearchResponse,
    | errors.ApiError
    | CloudinaryAssetMgmtError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, components.FoldersSearchResponse$inboundSchema),
    M.jsonErr([400, 401], errors.ApiError$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
